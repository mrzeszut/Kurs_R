---
title: "Przetwarzanie danych w R z zastosowanie pakietów tibble, dplyr, tidyr z rodziny mega-paietu tidyverse"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
    html_document:
      theme: spacelab
      highlight: kate
      toc: true
      toc_float: true
      collapsed: false
      smooth_scroll: false
      number_sections: false
      toc_depth: 3
      self_contained: true
      code_folding: show
bibliography: moja_bib.bib
link-citations: yes
editor_options: 
  chunk_output_type: console
  
---

<style type="text/css"> body  { font-size: 14px;} code.r{ font-size: 14px;} pre   { font-size: 14px} 
h1    { font-size: 24px;} h2    { font-size: 22px;} h3    { font-size: 20px;} </style>

***

**Mateusz Rzeszutek**

**AGH** Akademia Górniczo-Hutnicza im. Stanisława Staszica w Krakowie, Wydział Geodezji Górniczej i Inżynierii Środowiska, Katedra Kształtowania i Ochrony Środowiska

**e-mail:** *[rzeszut@agh.edu.pl](rzeszut@agh.edu.pl)*

**lokalizacja:**  bud. C-4, p. V, pok. 511, al. A. Mickiewicz 30, Kraków, Polska

**konsultacje:** Zgodnie z informacjami na stronie
[dziekantu](https://dziekanat.geod.agh.edu.pl/dziekanat/index.php?menu1=4&menu2=17&co=o&lin=o&wiad=@f_konsult_prez) lub po uzgodnieniu za pośrednictwem e-mail

***

![](logo_WGGiIS.jpg)

***



```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning=F,message=F,error=F)
#niversity of Science and Technology, Faculty of Mining Surveying and Environmental Engineering, Department of Environmental Management and Protection
```


Niniejszy materiał został opracowany na podstawie kursów i książek dostępnych online, tj.:

1. [Pogromcy danych](http://www.pogromcydanych.icm.edu.pl/). Kurs został opracowany w 2015 roku przez [Przemysława Biecka]([http://pbiecek.github.io/). Składa się z dwóch części tj.: 
  * Przetwarzanie danych w programie R,
  * Wizualizacja i modelowanie.
2. Data wrangling, exploration, and analysis with R, University of British Columbia, [stat545](http://stat545.com/) 
3. Przemysłąw Bieciek: [Przewodnik po pakiecie R 4.0](https://pbiecek.gitbooks.io/przewodnik/content/)
4. Garrett Grolemund, Hadley Wickham.: [R for Data Science](http://r4ds.had.co.nz/)

Szczególnie poleceam polecam pozycję nr 4, która została opracowana przez twórcóW mega-pakietu [tidyvers](https://www.tidyverse.org/). Jest to orginalna pozycja, która przedstawian inne, niepowtarzalne podejście do nauki programowania w R. Wiecej o pakiecie `tidyverse` powiemy trochę póżniej.


# 1. Czyszczenie danych 

Niniejszy rozdział odpowiada na jedno, ale niezwykle ważne pytanie. Jak prawidłowo przygotować dane przed rozpoczęciem analiz z wykorzystaniem pakietów dostępnych dla środowiska programistycznego R. 

## 1.1. Wprowadzenie

Praca z danymi to w dużej części czyszczenie i wielokrotna zmiana reprezentacji. Po co dane czyścić? Zarówno dane zbierane przez ludzi, jak i przez automatyczne czujniki, mają tendencje do zawierania braków, obserwacji odstających lub zwykłych błędów. Aby móc sensownie analizować dane, musimy przekształcić je do postaci w której wyniki analiz będą wiarygodne.

Czyszczenie to bardzo istotna faza. Bez względu bowiem jak zaawansowana i dobrze dobrana jest nasza technika analizy danych, jeżeli na wejściu będą śmieciowe dane to na wyjściu będą śmieciowe wyniki. 

> Garbage in garbage out

W ramach tego kursu nauczymy się edytować zbiory danych tak by doprowadzić je do spójnej, klarownej postaci. Zastępować wartości, identyfikować wartości odstające (zbędne), sprawdzać typy zmiennych, identyfikować błędy w danych. Jest to bardzo ważny i z reguły czasochłonny etap, jednak dopiero gdy posiadamy wyczyszczone dane możemy przejść do kolejnych etapów, czyli wstępnej obróbki, analizy i wizualizacji danych. 

### 1.1.1 Pakiet tidyverse

Przed rozpoczeciem ćwiczenia wczytaj pakiet `tidyverse`. `Tidyverse` to otwarty zbiór pakietów R zaprojektowanych na potrzby nauki o danych. Wszystkie pakiety mają wspólną filozofię projektowania, gramatykę i struktury danych.

```{r, message=F}
library(tidyverse)
```

Zauważ, że po wczytaniu pakietu `tidyverse` zostaje wczytany cały zbiór pakietów. Patrz okno konsoli. Pjawia się zbiór wiadomości `(message)`. Skrócona charakterystykę tych pakietów przedstawiono w poniższej tabeli.

| Pakiet   | Krótki opis                            |  
|:---------|:---------------------------------------|
|`ggplot2` |  Wizualizacja danych                   |
|`dplyr`   |  Przetwarzanie danych                  |
|`tidyr`   |  Porządkowanie danych                  |
|`readr`   |  Wczytywanie danych                    |           
|`purrr`   |  Programowanie funkcyjne               |
|`tibble`  |  Efektywniejsza odmiana ramki danych   |
|`stringr` |  Zmienne znakowe (character)           |
|`forcats` |  Zmienne jakościowe (factor)           |

Skrócony opis pakietów znajdziesz [tutaj: ](https://www.tidyverse.org/packages/). Dodatkowo zamieszczone są tam linki do przykładów i samouczków. W wielkim skrócie skarbnica wiedzy, ale to zostawcie sobie na póżniej. 

Aktualność naszego pakietu możemy sprawdzić następującym poleceniem. 

    tidyverse_update(recursive = F)

Oprócz wymienionych powyżej pakietów, wczytywane są również pakiety do importowania danych: 

 * `readxl` dla plików typu .xlsi .xlsx
 * `haven` dla plików SPSS, Stata i SAS data

Istnieje kilka innych pakietów, które nie są w `tidyverse`, ale są bardzo przydatne do importowania danych z innych źródeł:

 * `jsonlite` dla JSON.
 * `xml2` dla XML.
 * `httr` dla webowych interfejsów API.
 * `rvest` dla skrobania internetowej.
 * `DBI` dla relacyjnych baz danych. Aby połączyć się z określoną bazą danych, musisz sparować DBI z konkretnym z RSQLite, RPostgres lub odbc. 

Oprócz `tidyr` i `dplyr` istnieje pięć pakietów (w tym `string` i `forcats`), które są zaprojektowane do pracy z określonymi rodzajami danych:

 * `lubridate` dla daty i daty. *Temu pokietowi poświecimy chwilę uwagi*.
 * `hms` dla wartości *time-of-day*.
 * `blob` do przechowywania danych typu blob (binarnych).

Oprócz purrr , który zapewnia bardzo spójne i naturalne metody do iteracji obiektów R (Programowanie), istnieją dwa dodatkowe pakiety tidyverse, które pomagają w ogólnych wyzwaniach programowania:

* `magrittr` zapewnia operator *pipe*, `%>%` używany w całym tidyverse i w ramach tego kursu poświecimy mu bardzo dużo uwagi. Zapewnia również szereg bardziej wyspecjalizowanych operatorów *pipe*, np.:  `%$%` i `%<>%`, które mogą być przydatne.
* `glue` stanowi alternatywę dla `paste()`, która ułatwia łączenie danych i łańcuchów.

Mega-Pakiet `tidyverse` dysponuje również narzędziamy do modelowania, ale ten element zasadniczo odbiega od zakresu naszego kursu. Natomiast zmierzycie się z tymi zadaniamia na nie jednych zajeciach, których korzystać będziecie z regresi liniowej.

Listę pakietów można sprawdzić poleceniem:

```{r}
tidyverse_packages()
```


### 1.1.2 Przygotowanie danych

Zamin przejdziemy do ćwiczeń przygotujemy prosty zestaw danych w postaci obiektu `data.frame()`. Poniższy zbiór poleceń powinien być zrozumiały, jeśli nie to zalecam powtórkę wcześniejszych rozdziałów.

```{r}
id <- c(1:3, NA)
imie  <- c("Maja", "Anna", "Zosia", "Anna")
nazwisko <- c("Kowalski", "Ptak", "Kot", "Ryś")
wiek  <- c("40","12,5","25","16.6")
wzrosty <- round(runif(4, 150,210),1)
waga <- round(runif(4, 50, 100),1) 
oczo <- factor(c("niebieskie", "jasno-niebieskie", "ciemne", "ciemno-niebieskie"))

df <- data.frame(id, imie, nazwisko, wiek, wzrosty,  waga, oczo, stringsAsFactors = F)
```

Teraz podglądamy utworzone dane. np. poleceniem `df`

```{r, echo=F}
library(knitr)
df %>% kable()
```

## 1.2 Zmiana nazw kolum

Aby wyświetlić nazwy kolumn można wykorzystać funkcję `colnames()` lub `names()`. Wynikiem jest wektor napisów, można na elementach tego wektora używać indeksów podobnie jak w poniższym przykładzie. Analogicznie funkcja   `rownames()` pozwala na pracę z nazwami wierszy.

Zwraca nazwy kolumn.

```{r}
colnames(df)
```

Zmieniamy nazwę kolumny `oczo` na `oczy` oraz `wzrosty` na `wzrost`.

```{r}
colnames(df) <- c("id", "imie", "nazwisko", "wiek",  "wzrost", "waga", "oczy")
colnames(df)
```

Korzystajac z poznanego w poprzednich rozdziałach indeksowania można to zrobić znacznie prościej. Chcemy zmienić nazwę kolmny `oczy` na `kolor_oczu`.

```{r}
colnames(df)[7] <- "kolor_oczu"  
colnames(df)
```


#### Ćwiczenie 1.  {.tabset .tabset-pills}

##### Treść zadania

Korzystaliśmy z funkcji pakiety `base::colnames()`. Teraz wykonaj powyższe operacje, ale stosując funkcje `names()`. Pamiętaj by ponownie utworzyć obiekt (ramkę danych) `df`.

***

##### Rozwiązanie
    
```{r, eval=F}
df <- data.frame(id, imie, nazwisko, wiek, wzrosty,  waga, oczo,stringsAsFactors = F)

names(df) <- c("id", "imie", "nazwisko", "wiek",  "wzrost", "waga", "oczy")

names(df)[7] <- "kolor_oczu"  ; head(df, 1)

```

***

####


#### Ćwiczenie 2.  {.tabset .tabset-pills}

##### Treść zadania

Korzystając z funkcji `rownames()` zmień nazwy wierszy na pierwsze litery alfabetu.

***

##### Rozwiązanie
    
```{r, eval=T}
rownames(df) <- letters[1:4]
rownames(df)
```

***

####


W pakiecie `dplyr` istnieje również funkcja zmianiająca nazyw kolumn: `rename()`. Zauważ, że najpierw podajmy nową nazwę kolumny, a dopiero póżnie istniejącą nazwę  

```{r}
df <- data.frame(id, imie, nazwisko, wiek, wzrosty,  waga, oczo, stringsAsFactors = F)
rename(df, kolor_oczu = oczo, wzrost = wzrosty) -> df
colnames(df)
```

## 1.3 Zmiana przecinka na kropkę

Jeżeli pracujemy na danych wprowadzanych przez człowieka to często zdarza się, że raz wpisuje on jako separator dziesiętny znak . (kropka), a raz , (przecinek). Jeszcze więcej problemów tego typu występuje, gdy dane wprowadza kilka osób. np:


***

#### Ćwiczenie 3. {.tabset .tabset-pills}
##### Treść

Korzystając z funkcji `str()` przyjrzyj się zestawowi danych `df`.

 * Czy któraś z zmiennych ma nieprawidłowy typ ? 
 * akorzystając z funkcji `gsub()` z podstawowego pakietu `grep`. 
 * następnie przekształć zmienną na typ `numeric`
 * pomocy szukaj w pomocy programu R

```{r}
?gsub()
```


***

##### Rozwiązanie

```{r}
str(df)
```

Zmienna **wiek** jest typu `character`, a powinna przechowywać zmienną ilościową `(numeric)`. 

```{r}
df$wiek
```

Stało się tak ponieważ był błąd w wprowadzonych danych. Jest 12,5 a powinno być 12.5. Do podmiany znaków użyjemy funkcji `gsub()`. 

```{r}
gsub(pattern = ",", replacement = ".", df$wiek) -> df.wiek
df$wiek <- as.numeric(df$wiek)
typeof(df$wiek)
```

Jeszcze wykonajmy test i policzmy średnią i mediane

```{r}
mean(df$wiek, na.rm = T) ; median(df$wiek, na.rm = T)
```

####

***


## 1.4. Nazwy czynników w zmiennej jakosciowej

Gdy przetwarzamy zmienną jakościową, częstą operacją jest zmiana nazw poziomów, zmiana ich kolejności lub połączenie kilku poziomów w jeden.

```{r}
df$kolor_oczu
```

Aby wyświetlić lub zmienić nazwy poziomów można wykorzystać funkcję `levels()`. Tą  funkcją możemy wyświetlić wektor nazw lub go zmienić. Jeżeli przypiszemy do niego wartości z powtarzającymi się napisami, to wskazane poziomy zostaną połączone w jeden.

```{r}
levels(df$kolor_oczu)
levels(df$kolor_oczu) <- c("ciemne", "niebieskie", "niebieskie", "niebieskie")
```

Jeżeli chcemy zmienić kolejność poziomów w zmiennej jakościowej, to najłatwiej jest to zrobić z użyciem funkcji `factor()`. W argumencie levels możemy podać poziomy w dowolnej kolejności. Wartości są takie same, ale kolejność poziomów jest inna. Kolejność poziomów jest ważna w tworzeniu wykresów (odpowiada ona kolejności poziomów na wykresie) oraz w modelowaniu statystycznym.

```{r}
factor(df$kolor_oczu, levels=c("niebieskie", "ciemne"))
levels(df$kolor_oczu)
```

## 1.5. Usuwanie lub zastępowanie brakujących danych

W tym przypadku skorzystajmy z trochę większego zbioru danych `airquality`.

```{r}
airquality -> air
```

```{r, echo=FALSE}
library(DT)
DT::datatable(airquality, caption = "Tabela 1. Informacje o średnich dobowych stężeniach ozou na tle wybranych parametrów meteorologicznych")
```

Nie trudno zauważyć, że występuje wiele pustych wartości `NA` w zmienych `Ozone`, i `Solor.R`.Takie wartości możemy usunąć (tzn. usunąć musimy cały wiersz) korzystając z funkcji `na.omit()`. lub podmienić wartoscią średnią z zbioru danych.

```{r}
na.omit(air) -> air1
nrow(air) ; nrow(air1) ; nrow(air) - nrow(air1)
```

W wyniku tej opreacji usuneliśmy 42 wiersze danych, które mogły zawierać istotne dla nas obserwacje. Te braki są widoczne na poniższym rysunku. Wartosci liczbowe w nagłówku rysunku oznaczają miesiące.

```{r, echo=F}
ggplot(air , aes(x = Day, y = Ozone)) +
  geom_line(col = "blue", size = 1) + 
  geom_point(size = 2, col = "red") +
  facet_wrap(~Month, nrow = 3) +
  geom_hline(yintercept = mean(air$Ozone, na.rm = T),linetype = "dotdash", size = 0.9)
```

Podmieńmy zatem braki danych 'NA' wartością średnią. Najpier identyfikujemy zbiory pustych danych.

```{r}
puste <- which(is.na(air$Ozone))
length(puste)
```

Funkcja with zwróciła nam numery wierszów, które są puste. Teraz za pomocą indeksowania możemy podmienić wartosci `NA`.

```{r}
air$Ozone[puste] <- mean(air$Ozone, na.rm = T)
```

Teraz nasz wykres jest kompletny. Natomiast już na pierwszy rzut oka, można stwierdzić że ta metoda jest mało reprezentatywna dla czerwca (6), gdzie występowała duża ilość brakóW danych.

```{r, echo=F}
ggplot(air , aes(x = Day, y = Ozone)) +
  geom_line(col = "blue", size = 1) + 
  geom_point(size = 2, col = "red") +
  facet_wrap(~Month, nrow = 3)
```

#### Ćwiczenie 4. {.tabset .tabset-pills}
##### Treść

* Wyselekcjonuj z zestawu danych `air2` (patrz niżej) tylko zbiór wartości dla czerwca.
* Określ ile wsytępuje brakujących danych w tym miesiącu.
* Jaki jest stosunke wartości pustych do całkowitej ilosci obserwacji.
* Podmień wartosci puste medianą.
* Zastosuj funkcję `complete.cases()` oraz określ co ona robi ale dla Month == 5: air2[!complete.cases(air2),].

```{r}
airquality -> air2
```

***

##### Rozwiązanie

```{r}
air2[air$Month == 6,] -> air2

puste <- which(is.na(air2$Ozone)) ; length(puste)

length(puste)/nrow(air2) # wow 70 % 

air2$Ozone[puste] <- median(air2$Ozone, na.rm = T)

airquality -> air3 ; air2[air$Month == 5,] -> air3
complete.cases(air3)

air3[!complete.cases(air3),] 

air3[!complete.cases(air3),] 

```


####

***

## 1.6. Normalizacja danych

W analizie danych często spotykamy się z sytuacją, gdy dane w kolumnie chcemy unormować. Unormować, czyli wycentrować, a więc usunąć z nich wartość średnią (tak by średnia była równa 0), i przeskalować, czyli podzielić tak, aby odchylenie standardowe było równe 1.

Do normalizacji można wykorzystać funkcję scale(). Domyślnie centruje i skaluje ona dane, ale ustawiając dodatkowe argumenty możemy wyłącznie wycentrować lub przeskalować dane. Przetestujmy:

```{r}
scale(air$Ozone, center = F, scale = T) -> a1 # Skalowanie
scale(air$Ozone, center = T, scale = F) -> a2 # centrujemy
scale(air$Ozone, center = T, scale = T) -> a3 # skalujemy i centrujemy, czyli normalizacja
```

Sprawdźmy jak znormalizowane dane wygladają na wykresie. 

```{r, echo=F}
data.frame(id = rep(1:153,4),
           ozone = c(a1, a2, a3, air$Ozone),
           typ = c(rep("a1", 153), rep("a2", 153), rep("a3", 153), rep("origin", 153))) -> a

ggplot(a, aes(x = id, y = ozone, colour = typ, shape = typ)) + 
  geom_point() +
  geom_line()
```

A teraz porwnajmy praktykę z teorią. 

```{r, echo=F}
a %>% group_by(typ) %>% 
  summarise(odch.stand = sd(ozone),
            srednia = mean(ozone)) %>% kable()
```

**To był materiał nieobowiązkowy, więc nie będzie go na kolokwium** 

## 1.7. Podmiana dowolnej wartości

Często się zdarza, że w kolumnie podmienić trzeba wszystkie wartości na inne. Być może ktoś omyłkowo wpisał 100.00 zamiast 10000 i trzeba zastąpić wartość. Być może ktoś źle wpisywał nazwy leków itd. Na przykładzie poniżej zastąpimy kolor oczu niebieskie na zielone. 

Wynik przyrównania zwraca wektor wartości logicznych.

```{r}
df$kolor_oczu=="niebieskie"
```

Można ten wektor wykorzystać do indeksowania wiersza. Jeżeli do kilkuelementowego wektora przypiszemy jedną wartość, tak jak w przykładzie poniżej, to wszystkie elementy tego wektora zostaną zastąpione przez tę wartość.

```{r}
df$kolor_oczu <- as.character(df$kolor_oczu)
df$kolor_oczu[df$kolor_oczu=="niebieskie"] <- "zielone"
```

W wyniku tej instrukcji otrzymujemy nowy, zmieniony zbiór danych.

```{r, echo=F}
df %>% kable()
```


#### Ćwiczenie 4. {.tabset .tabset-pills}
##### Treść

* Zidentyfikuj czy w zbiore danych df występują wartosci `NA` funkcją `complete.case()`
* Podmień je odpowiednią wartością.

***

##### Rozwiązanie

```{r}
df[!complete.cases(df),]
df$id[is.na(df$id)] <- 4
df$wiek[2] <- mean(df$wiek, na.rm = T)
df
```

***

####

Skonczyliśmy pracę już z zestawami danych znajdującymi się w oknie `Envirnment`, więc usuniemy wrzystkie niepotrzebne zmienne. Służy do tego polecenie `rm()`, a polecenie `ls()` wywołuje wektor nazw zmiennych.

```{r}
ls() ; rm(list=ls())
```

***
***

Do zagadnień z wiaznych z czuszczenie danych wrócimy przy okazji omawiania pakietu `tidyr`. Warto przytoczyć na koniec dwa cytaty zawarte w @Wickham:2017:RDS:3086927.

***

*Wrzystkie szczęśliwe rodziny są do siebie podobne; każda nieszczęścliwa rodzina jest nieszczęścliwa na swój własny sposób.* --- Lew Tołstoj

*Wrzystkie czyste zestawy danych są do siebie podobne, ale każdy zabałaganiony zestaw danych jest zabałaganiony na swój własny sposób.* --- Hadley Wickham

***

Materiał specjalny, który pozwoli lepiej zrozumieć podstawy teoretyczne [Tidy data](https://www.jstatsoft.org/article/view/v059i10) oraz z cyklu wielkich postaci:

*** 

*Co my wiemy, to tylko kropelka. Czego nie wiemy, to cały ocean* --- Isaac Newton

***
 
## Zadanie nr 1. 

Po wczytaniu poniższej ramki danych napraw następujące błędy:

* popraw nazwę kolumny litary,
* zamień wartości X i Y odpowiednio na A i C,
* zamień kolumnę liczby na kolumnę liczb,
* zastąp brakujące dane w kolumnie braki.
    
```{r, eval=F}
df <- data.frame(
  litary = c("X","B","Y","D"),
  liczby = c("1","2","3,0","4,0"),
  braki = c(NA,1,NA,1), 
  stringsAsFactors = F)
```

***
***
***

# 2. Obiekt typy tibble

Obiekt `Tibble`, czy `tbl_df` to nowoczesny odpowiednik `data.frame`. Tibbles to data.frames, które robią mniej, dzięki wymuszają na nas odpowiednie dopracowanie danych już na poziomie wczytania. Nie zmieniają: 

* nazw zmiennych 
* typów zmiennych
* nie dokonują częściowego dopasowywania

Gdy zmienna nie istnieje, to zmusza nas do wcześniejszego stawienia czoła problemomi, zwykle prowadzi to do czystszego, bardziej ekspresyjnego kodu. Tibble mają również ulepszoną metodę print(), która ułatwia ich używanie w dużych zestawach danych zawierających złożone obiekty.

[tibble](https://tibble.tidyverse.org/)

Gdyby poniższe materiały okazały się dla Ciebie niezrozumiałe to Więcej o tibble znajdziesz w @Wickham:2017:RDS:3086927 [link](http://r4ds.had.co.nz/tibbles.html)


## 2.1 Tworzenie obiektu tibble i konwersja na tibble

Skorzytsamy z zestawu danych `iris` oraz `flights`. W celu pozyskania zestawu `flights` zainstaluj i wczytaj pakiet `nycflights13`

    install.packages("nycflights13")
    library(nycflights13)


```{r include=FALSE}
library(nycflights13)
library(tidyverse)
```

Konwersję wykonujemy za pomocą funkcji `as_tibble()` lub `dplyr::tbl_df()`. 

```{r}
tibble::as_tibble(iris)
```

Zauważ, żę Tibby mają udoskonaloną metodę drukowania, która pokazuje tylko pierwsze 10 wierszy i wszystkie kolumny pasujące do ekranu. To znacznie ułatwia pracę z dużymi danymi. Oprócz nazwy każda kolumna zgłasza swój typ, co zapożyczono z `str()`.

```{r}

```


Obiekty tible tworzymy analogicznie jak w przypadku data.frame tylko z wykorzystaniem funkcji `tibble`, lub z pomocą funkcji `tribble`. 

```{r}
tibble(a = runif(5,5,30), b = 2-1, z = a ^ 2 + b)
```

Ta druga jest szczególnie przydatna, gdy kopiujemy dane z przeglądarki, czy pliku do skryptu programu R. W przypadku funkcji trible, nazwy zmiennych poprzedzamy tyldą `~`, a wartosci odzielamy przecinkami.

```{r}
tribble(
  ~x, ~y,  ~z,
  "a", 2,  3.6,
  "b", 1,  8.5
)
```

Należy pamiętać, że funkcja `tibble` będzie ignorować nie standardowe znaki. W takim przypadku należy wprowadzić nazwę w pojedyńćzych apostrofach `'nazwa'`

```{r}
tb <- tibble(
  `(:)` = "ikona", 
  `   ` = "pusta przestrzen",
  `100` = "liczba")
tb
```


## 2.2 Różnice względem data.frame

**[Drukowanie na ekranie konsoli]**. Tibbles są zaprojektowane tak, aby przypadkowo nie obciążyć konsoli podczas drukowania danych. Czasami potrzebujesz szerszego podglądu niż domyślny wyświetlacz. Jest kilka opcji, które mogą pomóc. Najpierw można za pomocą `print()` określić ramkę danych i kontrolować liczbę wierszy `(n)` i szerokość ekranu `width = Inf` --- wyświetli wszystkie kolumny. Zawsze też można skorzystać z funkcji `View()`.

```{r}
mtcars <- as.tibble(mtcars)
print(mtcars, n = 5, width = Inf) 
```

Spróbuj wpisać większą ilość wierszy np 15. 

**[Ekstrakcja, wybieranie podzestawu danych]**

Kolumny w obiekcie `tibble` możemy wybierać analogicznie jak w przypadku data.frame. 

```{r, echo=F}
mtcars$vs
```

Przy indeksowaniu stosujemy analogiczne zasady, ale jeśli chcemy wydzielić wektor a nie obiekt tibble to stosujemy podwójne nawiasy kwadratowe.

```{r, echo=F}
mtcars[[8]] # kolumna vs
mtcars[[1,8]] # kolumna vs i pierwszy element
```

Można oczywiscie stosować róWnież nazwy kolumn.

```{r, echo=F}
mtcars[["vs"]]
```

Pamiętaj, że wiele funkcji z starszych, czy nawet obecnych pakietów może nie działać na obiektach tibble. Może być to czasami uciażliwe. 

**[Przetwarzanie potokowe]**

Przetwarzanie potokowe omówimy póżniej. Natomiast zapamietaj, że w przetwarzaniu potokowym w przypadku selekcji ww. metodami trzeba dać kropkę po operatorze pipe `%>%`.

```{r, echo=F}
mtcars %>% .$vs
mtcars %>% .[["vs"]]
mtcars %>% .[[8]]
```


## 2.3 Kilka przydatnych funkcji

Zauważ że zestaw danych `mtcars` po załadowaniu ma nazwy wierszy, które odpowiadają nazwą modeli pojazdóW, są typu `character`.


```{r}
data(mtcars) ; head(mtcars)
head(as.tibble(mtcars))
```

Po konwersji na obiekt tibble nazwy wierszy znikneły. Obiekt tible nie wyświetla w podglądzie nazw wierszy.

```{r}
as.tibble(mtcars) -> mtcars_tbl
row.names(mtcars_tbl)
```

Natomiast one nie znikają:

```{r}
has_rownames(mtcars)
has_rownames(mtcars_tbl)
```

Można temu zaradzić korzystając z funkcji pakietu tibble. Ciekawostką jest to, że poniższe funkcje działają tylko na obiekcie typu data.frame().

```{r}
rownames_to_column(mtcars,var = "nazwa") -> mtcars
head(mtcars)
head(column_to_rownames(mtcars, var = "nazwa"))
```


```{r}
tbl_nongroup_vars(mtcars)
tbl_sum(mtcars$cyl)
```


Więcje o pakiecie tibble znajdziesz [tutaj](https://cran.r-project.org/web/packages/tibble/tibble.pdf)

## Zadanie nr 2 

Sprawdźć jak działają niżej wymienione funkcje (Powtórka) z obiektem typu tible. Skorzystaj z zestawu danych `flights`.

* str()
* dplyr::glimpse() # nowa funkcja
* class()
* typeof()
* head()
* tail()
* colnames()
* names()
* ncol()
* length()
* dim()
* nrow()
* summary()

Czy zaobserwowałeś jakieś różnice ?

***
***
***

# 4. Selekcja
# 5. Filtrowanie + operatory
# 6. Potoki "pipe"
# 7. Sortowanie 
# 8. Agregowanie i funkcje wektorowe
# 9. Grupowanie
# 10. Tworzenie nowych cech
# 11. Wąska i szeroka reprezentacja (tidyr)
# 12. Relacyjne zestawy danych (join)
