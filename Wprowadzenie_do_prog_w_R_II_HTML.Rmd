---
title: "Wprowadzenie do programowania w R"
subtitle: "Podstawy programowania w R"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
    html_document:
      theme: spacelab
      highlight: kate
      toc: true
      toc_float: true
      collapsed: false
      smooth_scroll: false
      number_sections: false
      toc_depth: 4
      self_contained: true
      code_folding: NULL
bibliography: moja_bib.bib
link-citations: yes
editor_options: 
  chunk_output_type: console
---

<style type="text/css"> 
body { font-size: 14px; text-align: justify} code.r{ font-size: 14px;} pre { font-size: 14px} 
h1   { font-size: 24px;} h2 { font-size: 22px;} h3 { font-size: 20px;} 
</style>

***

**Mateusz Rzeszutek** 

**AGH** Akademia Górniczo-Hutnicza im. Stanisława Staszica w Krakowie, Wydział Geodezji Górniczej i Inżynierii Środowiska, Katedra Kształtowania i Ochrony Środowiska.

**e-mail:** *[rzeszut@agh.edu.pl](rzeszut@agh.edu.pl)*.

**lokalizacja:**  bud. C-4, p. V, pok. 511, al. A. Mickiewicza 30, Kraków, Polska.

**konsultacje:** Zgodnie z informacjami na stronie
[dziekanatu](https://dziekanat.geod.agh.edu.pl/dziekanat/index.php?menu1=4&menu2=17&co=o&lin=o&wiad=@f_konsult_prez) lub po uzgodnieniu za pośrednictwem e-mail.

***

![](rys/logo_WGGiIS.jpg)

***

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning=F,message=F,error=F)
```


# 1. Wprowadzenie

Potrafisz już założyć nowy projekt w `RStudio`, instalować pakiety oraz wiesz gdzie i jak szukać informacji o `R`. Najwyższy czas zacząć pracę z `R`. W ramach tematu *Podstawy programowania w R* nauczysz się:

1. jak wykonywać obliczenia,
2. jak pracować z różnego typu danymi,
3. jak tworzyć obiekty,
4. tworzyć zmienne,
5. indeksować obiekty,
6. wykonywać operacje algebraiczne i logiczne na obiektach,
7. oraz wczytywać i zapisywać dane.

Zanim zaczniesz, otwórz projekt `RStudio`, który utworzyłeś na ostatnich zajęciach. Jeśli go nie masz przy sobie to utwórz nowy. Najlepszym rozwiązaniem jest zakąłdanie projektu w rozpakowynm folderze, który pobrałeś z [upel](upel.agh.edu.pl).

Bezpiecznym rozwiązaniem jest zapisywać projekt na nośniku zewnętrznym (pendrive, dysk przenośny). Natomiast z doświadczenia wiem, że czasem zdarza się zapomnieć wziąć go ze sobą. W związku z tym możesz stworzyć kopie na dysku google lub innej darmowej usłudze do przechowywania i synchronizacji plików. To drugie rozwiazanie jest bezpieczne, ale wymaga ciągłego kopiowania.

***

# 2. R jako kalkulator

## 2.1 Podstawowe operacje arytmetyczne

Program R może służyć jako kalkulator matematyczny. Zaczniemy od wykonania kilku prostych działań. W tym ćwiczeniu zachęcam do bezpośredniej pracy z `konsolą R` z pominięciem okna skryptów.

Najpierw poznamy podstawowe operatory arytmetyczne:

```{r, echo=F}
knitr::kable(data.frame(
Operator = c("-", "+", "*","/","^ lub **","%%", "%/%"),
opis = c("Odejmowanie", "Dodawanie", "Mnożenie (iloczyn)", "Dzielenie (iloraz)", 
         "Potęgowanie","Reszta z dzielenia", "Część całkowita z dzielenia")), 
caption = "Tabela 1. Zestawienie operatorów arytmetycznych stosowanych w R")
```

Znajac już operatory Wykonaj poniższe podstawowe polecenia w konsoli R i sprawdź jakie otrzymasz odpowiedzi:

```{r, eval=F}
2+2
2^2
4^2
1/10
(3+7)^(4-2)
8%%3
8%/%3
```

Po wpisaniu polecenia należy nacisnąć Enter w celu uruchomienia wykonania operacji obliczeniowej. Wynik wyświetli się w oknie. 

Uwaga !!! W przypadku gdy polecenie nie zostało ukończone, a wcisnąłeś Enter, konsola poprosi Cię o dokończenie polecenie poprzez wyświetlenie znaku +. np.:

```{r, eval=FALSE}
## wpisz 
2+ 
## wciśnij enter
## wyświetli się znak plusa +
## wpisz 2
2 
## naciśnij enter i zobacz co się stało.
```

Ten problem pojawia się dość często, gdy mamy wiele nawiasów. Zdarza się któryś z nich pominąć, gdy jest ich bardzo dużo. W `R` można wykonywać wiele poleceń w jednej lini kodu. Do tego celu służy średnik: `;`, który rozdziela polecenia.

```{r}
2+2 ; 2+5 ; 9^2 ; "itd..."
```

***

##### Ćwiczenie 1 {.tabset .tabset-pills}
###### Treść 
Które operatory arytmetyczne mają pierwszeństwo

* mnożenie, czy dzielenie?
* mnozenie, czy dodowanie?
* potęgowanie, czy dzielenie?
* dzielenie, czy dodwanie?

###### Odp.

Nawias wymusza pierwszeństwo. Przykłady móWią same za siebie.

```{r}
10/5*2  ; (10/5)*2 ; 10/(5*2)
2*2+100 ; 2*(2+100)
4^2/2  ; 4^(2/2)
2/2+2 ; (2+2)/2
```

####

***

## 2.2. Funkcje arytmetyczne 

Wspominaliśmy, żę R ma wbudowanych kilka pakietów podstawowych. W pakiecie `base` jest  szereg podstawowych  funkcji stosowanych na co dzień podczas korzystania z programu R. Pełną listę funkcji dostępnych w pakiecie base wywołać można poleceniem:

```{r, eval=F}
?base
library(help = "base")
```

Pakiet ten zawiera bardzo dużo funkcji. Pozwalają one na wykonywanie operacji arytmetycznych m.in. na pojedynczych liczbach. Poniższa tabela przedstawia zestawienie wybranych funkcji wraz z opisem.

```{r, echo=F}

library(tidyverse)
knitr::kable(
tribble(
  ~"Funkcja", ~"Opis funkcji",
"round(x)",    "Liczba całkowita najbliższa wartości x",
"signif(x,k)", "Wartość x zaokrąglona do k miejsc znaczących",
"floor(x)",    "Podłoga, czyli największa liczba całkowita nie większa od x",
"ceiling(x)", "Sufit, czyli najmniejsza liczba całkowita nie mniejsza od x",
"trunc(x)", "Wartość x po odcięciu części rzeczywistej, dla liczb dodatnich działa jak floor(), dla ujemnych jak ceiling",
"abs(x)", "Wartość bezwzględna z x",
"log(x)", "Logarytm naturalny z x",
"log(x, base)", "Logarytm o podstawie base z x",
"log10(x)", "Logarytm o podstawie 10 z x",
"log2(x)", "Logarytm o podstawie 2 z x",
"exp(x)", "Funkcja wykładnicza (eksponenta) z x",
"expm1(x)", "Funkcja równoważna wyrażeniu exp(x)-1, ale wyznaczona z większą dokładnością dla x|«1|",
"log1p(x)", "Funkcja równoważna wyrażeniu log(1+x), ale wyznaczona z większą dokładnością dla x|«1|",
"sqrt(x)", "Pierwiastek kwadratowy z x, równoważne poleceniu x^0.5"
), caption = "Tabela 2. Zestawienie wybranych funkcji pakietu base")

```

W ramach ćwiczenia Wykonaj poniższe operacje.

```{r, eval=FALSE}
round(2.5)         ; round(2.51)
signif(1.22562, 4) ; signif(1.22562, 2)
floor(23.45)       ; floor(23.75)     
ceiling(23.45)     ; ceiling(23.57)
trunc(23.25)       ; trunc(23.89)
abs(-54.2) ; abs(54.2)
log(10)    ; log(1)
log(10,10) ; log10(10)         
log(100)   ; exp(5)            
exp(0)     ; exp(1)
sqrt(4)    ; sqrt(36)
```

**Uwaga !!!** Separatorem miejsc dziesiętnych jest kropka. Separator miejsca dziesiętnego można ustawić w:

* Panel sterowania / Zegar, język i region / region / 
* Zakładka format, wybierz ustawienia dodatkowe
* W oknie symbol dziesiętny wprowadź kropkę (.) zamiast przecinka (,)


Zauważ, że funkcja może przyjmować więcej niż jeden argument. W większości przypadków wprowadzaliśmy jedną wartość liczbą, a w niektórych dwie wartości. Przyjrzymy się więc pomocy funkcji `round()`

```{r, eval=FALSE}
?round
```

Zauważ, że funkcja ta może przyjmować dwa argumenty: 

* `x` - liczba lub wektor,
* `digits` - liczba miejsc po separatorze miejsc dziesiętnych.

Wykonjamy teraz dwa polecenia stosując nazwy argumentów i zakładając, że chcemy zaokrąglić liczbę 2.2545, odpowiednio do liczby całkowitej oraz 1, 3, 4 miejsca po przecinku.


```{r}
round(x = 2.2545) ; round(x = 2.2545, digits = 1) 
round(2.2545, 3) ; round(2.2545, 4)
```

Zauważ, że gdy nie podamy argumentu `digits`, funkcja przyjmie ustawienia domyślne, czyli `digits = 0`. Ponadto nie musimy stosować nazw argumentów, jeśli podajemy je we własnosćiaściwej kolejności, co jest bardzo wygodne i skraca czas pisania poleceń. Zgodnie z powyższym przykłądem, wektor składa się z 4 elementów typu `character`.

Przyglądnij się, jak funkcja `round()` gdy zaokrągla wartości liczbowe, zwróć uwagę na wartość oznaczającą połowę (5). Spróbuj odpowiedzieć na pytanie jaka jest zasada zaokrąglania.

***

##### Ćwiczenie 2 {.tabset .tabset-pills}
###### Treść 
Wykonaj następujące polecenia:

* Oblicz pierwiastek 4 stopnia z liczby 16.
* Zaokrągl liczbę 1.23446789, do 3 miesjca po przecinku.
* Wyznacz wartość bezwzględną liczby -23.
* Oblicz pierwiastek i logarytm dziesiętny z liczby 100 w jednej linii poleceń.
* Oblicz logarytm dziesiętny z 1000 stosując dwie różne funkcje, w jednej linii poleceń.

###### Odp.

```{r}
16^(1/4)
round(1.23446789, 3) # działa dobrze ? 
abs(-23)
sqrt(100) ; log10(100)
log(1000, 10) ; log10(1000)
```

####

***

## 2.3. Funkcje trygonometryczne 


Funkcje trygonometryczne operują na argumentach podanych w radianach, a nie stopniach. Chcąc przeliczyć stopnie na radiany można skorzystać z wzoru: $rad = \alpha * \frac{\pi}{180}$. Gdyby ktoś nie wiedział co to radian to zapraszam na stronę [WWW](http://home.agh.edu.pl/~rudnicki/Cw1/radian.htm)


Zestawienie funkcji trygonometrycznych:

```{r, echo=F}

knitr::kable(
tribble(~"Funkcja", ~"Opis funkcji",
"cos(x)/sin(x)",   "Wartość funkcji cosinus/sinus w punkcie x",
"tan(x)",          "Wartość funkcji tangens w punkcie x",
"acos(x)/asin(x)", "Wartość funkcji arcus cosinus/sinus w punkcie x",
"atan(x)",         "Wartość funkcji arcus tangens w punkcie x",
"atan2(y, x)",     "Funkcja wyznaczająca kąt (w radianach) pomiędzy osią OX a wektorem o początku w punkcie (0,0) a końcu w punkcie (x,y).Wygodna funkcja do zamiany współrzędnych w układzie kartezjańskich, na współrzędne w układzie biegunowym"), caption = "Tabela 3. Zestawienie funkcji trygonometrycznych")

```

W celu przeliczania stopni na radiany można również wykorzystać funkcje `rad()`, ale wymaga to instalacji pakietu `circular`. 

W ramach przypomnienia podstaw matematyki, wykres funkcji: 
\[y = cos(x)\]
\[y = sin(x)\]

```{r, fig.align='center', fig.height=3, fig.width=8, echo=F}
library(ggplot2)

data.frame(
x <- seq(-10,10,0.1),
y1 = sin(x),
y2 = cos(x)) -> df
  
ggplot(data = df) + 
  geom_line(aes(x = x, y = y1, color = "sin(x)")) +
  geom_line(aes(x = x, y = y2, color = "cos(x)")) + 
  labs(x = "oś X", y = "oś Y", color = "Funkcja") +
  geom_vline(xintercept = 0) +
  geom_hline(yintercept = 0) + 
  scale_color_manual(values = c("red", "blue"))
rm(df)
```

***

##### Ćwiczenie 3 {.tabset .tabset-pills}
###### Treść 
Wykonaj następujące polecenia:

1. Oblicz sinus, cosinus, arcus tanges, arcus sinus kątów 0°, 30°, 45°, 90°, 180°, 360°
2. Przelicz współrzędne (x,y) (0,1); (1,1); (1,0); (1,-1); (0,-1); (-1,-1); (-1,0); (-1,1) na biegunowe. Wyznacz kąt (alfa) w stopniach oraz odległość (r) względem punktu 0.0. 

###### Odp.

**Rozwiązanie zadania pierwszego.**

```{r, echo=F}
rad <- c(0, 30, 45, 90, 180, 360)* (pi/180)

a <-data.frame( 
    rad = round(rad,3),
    sin = round(sin(rad),3),
    cos = round(cos(rad),3),
    atan = round(atan(rad),3),
    asin = round(asin(rad),3))
a[is.na(a)] <- NA 
knitr::kable(a, row.names = T, caption = "Tabela 4. Wyniki działań funkcji sinus, cosinus, arcus tanges, arcus sinus kątów dla katów 0°, 30°, 45°, 90°, 180°, 360°")
rm(rad)
```

> Dlaczego funkcja `asin(x)` zwraca wartości `NaN`. 

***

**Rozwiązanie zadania drugiego.**

```{r, echo=F}
#install.packages("useful")
library(useful)
x <- c(0,1,1,1,0,-1,-1,-1) ;y <- c(1,1,0,-1,-1,-1,0,1)
useful::cart2pol(x,y) -> a
a$alpha <- a$theta*(180/pi)
knitr::kable(a[,c(3,4,1,5,2)], caption = "Tabela 5. Wartości współrzędnych x,y w układzie biegunowycm alfa, r")
```


```{r, echo=F, fig.align='center', fig.cap= "Rys. 2. Wykres współrzędnych, wraz z wartościami katą alfa i odeleglości od punktu 0.0"}
a$etykieta <- paste("alfa = ",a$alpha,", ", "r = ", round(a$r,2))

ggplot(a, aes(x, y, label = etykieta)) + 
  geom_rect(xmin = -1, xmax = 1, ymin = -1, ymax = 1, 
            fill = "azure2", size = 1, linetype = 1) +
  geom_label(nudge_x = 0.2, nudge_y = 0.2)  +
  geom_point(size = 3, color = "red", shape = 16) + 
  xlim(-1.3,1.42) + 
  ylim(-1.3, 1.3) +theme_light()
  
rm(x,y,a)
```


####

***

## 2.4 Operatory logiczne i relacyjne

Ostatnim elementem tego rozdziału jest zrozumieniu operacji logicznych oraz relacyjnych, których wynikiem jest wartość logiczna. W R występują dwa rodzaje wartości logicznych `TRUE` i `FALSE`. Wykonywać możemy na nich operacje:

```{r, echo=F}
knitr::kable(data.frame(Operacja = c("!x", "x | y", "x & y"), 
                        Znaczenie = c("negacja","alternatywa","koniunkcja")),
             caption = "Tabela 6. Operatory i funkcje logiczne")
```

Zerknij również do pomocy `?Logic`.

Teraz wykonamy kilka operacji, które lepiej pozwolą ci zrozumieć działanie tych operacji

```{r, eval=F}
!FALSE # negacja
!TRUE # negacja
FALSE | FALSE # alternatywa
TRUE  | TRUE # alternatywa
TRUE  | FALSE # alternatywa
FALSE & FALSE # koniunkcja
TRUE  & TRUE # koniunkcja
TRUE  & FALSE # koniunkcja
```

Wartość logiczna jest róWnież zwracana przez R, gdy stosujemy operatory logiczne.

```{r, echo=F}
knitr::kable(data.frame(
Operacja = c("x < y","x > y","x <= y","x >= y","x == y","x != y"),
Znaczenie = c("czy mniejszy?", "czy większy?", "czy nie większy?", 
               "czy nie mniejszy?", "czy równy?", "czy nie równy"))
, caption = "Tabela 7. Operatory relacyjne")
```

Zerknij również do pomocy `?Comparison`. 

Wykonaj Kilka przykładów:

```{r,eval=FALSE}
1 > 3
3 >= 3
5 == 5
5 != 5
5 == 5 & 5 != 5 
5 == 5 | 5 != 5
```

***

# 3. Obiekty i typy danych

Każdy język programowania można postrzegać jako narzędzie służące do instruowania komputera, w jaki sposób należy przkształcić dane wejściowe, aby otrzymać interesujące dane wyjściowe [@gkagolewski2014programowanie]. W celu efektywnego korzystania z języka programowania musimy poznać obiekty stosowane w języku programowania `R`. Najważniejszymi obiektami stosowanymi w `R` są:

1. Wektory, `(vector)`.
2. Listy, `(list)`.
3. Macierze, `(matrix)`.
4. Tablice, często zwane ramkami danych, `(data.frame)`.
5. Funkcje, `(function)`.

W R wszystko jest obiektem, a każdy obiekt ma swoje własnosći. To co w matematyce określamy pojęciem zbioru lub dziedziny w R nazywamy typem obiektu. Obiekty w języku programowania mogą być różnego typu, lub często składać się z wielu elementów różnego typu (tzw. struktury złożone). PZgodnie z powyższym przykłądem, wektor składa się z 4 elementów typu `characterdstawowe typy obiektów w R, to:`, element"a"

1. Liczbowy `(numeric)`, który dzielimy na liczby całkowite `(integer)` i liczby rzeczywiste `(double)`.
2. Znakowy `(character)`, w postaci ciągu znaków.
3. Czynnikowy `(factor)` lub wyliczeniowy, kategoryczny, służy do grupowania danych.
4. Logiczny `(logical)`, przechowyjący informacje w postaci `TRUE` i `FALSE`.
5. Daty `(as.POSIXct)`.

Więcej informacji na temat podstawowych i złożonych typów danych języka R znajdziecie w @gkagolewski2014programowanie

Własnosćiasności obiektu w języku R możemy sprawdzać, za pomocą kilku funkcji:

```{r, echo=FALSE}
library(tidyverse)
knitr::kable(
tribble(~"Funkcja", ~"Opis funkcji",
"class()",  "klasa, typ obiektu",
"typeof()", "typ obiektu",
"length()",  "długość obiektu",
"attributes()",  "atrybuty obiektu",
"attr()", "dostęp do atrybutów obiektu",
"object.size()", "wielkość obiektu w bajtach",
"mode()", "wewnętrzna reprezentacja obiektu",
"str()", "szczegóły wewnętrznej reprezentacji obiektu"
), caption = "Tabela 2. Zestawienie wybranych funkcji zwracającyh informacje o własnosćiasnościach obiektu"
)
```

**Postaraj się zapamiętać:** `str(), class(), lenght(), typeof()` - będziemy z nich często korzystać.

***

## 3.1. Zmienna

Zanim przejdziemy do pracy z poszczególnymi obiektami w `R`, postaram się przybliżyć wam pojęcie **zmiennej** w `R`. Zmienne przechowują wprowadzane dane. np.: liczby, tekst, wektory liczb, wektor elementów tekstowych itd. Mogą również przechowywać informację o wynikach operacji arytmetycznych. Zmienne mogą w zasadzie przechowywać wszystkie dostępne typy obiektów, które zostaną omówione szerzej w kolejnych podrozdziałach. Aby przypisać zmiennej wartość należy zastosować operator. Tym operatorem jest znak przekazania wartości (<-), (->), (=). Pierwsze dwa operatory są operatorami nadrzędnymi względem operatora znaku równości.

Wykonajmy kilka przykładów. Wykonując poniższe polecenia zwróć uwagę na zakładkę `environmental` w prawym górnym oknie programu RStudio.

```{r, eval=F}
a = 2      ## definiujemy zmienną a
b = 3      ## definiujemy zmienną b
a          ## wyświetla wartość zmiennej a
b          ## wyświetla wartość zmiennej b
a+b        ## zwraca wyniki dodawania zmiennych
d <- a+b   ## zapisuje winik pod zmiennej d 
d          ## wyświetla wartość zmiennej d
```

Kilka bardziej złożony przykładów:

```{r, eval=F}
27+abs(-12.4)*(1/2)^exp(2)-100 * sqrt(0.3)
d <- 27+abs(-12.4)*(1/2)^exp(2)-100 * sqrt(0.3)
d 
z <-c/(a*2)+10^b
z
```

Teraz, kilka przykładów z trochę innej beczki:

```{r, eval=F}
nazwa <- "nazwa"
logiczny <- "TRUE"
inny <- "5"
calko1 <- 5
calko2 <- 5L
rzecz <- 3.876
nic <- NA
pusty <- NULL
```

Korzystając z funkcji `str()`, `class()`, `lenght()`, `typeof()` sprawdźć własnosćiąsności obiektów: `a`, `b`, `d`, `z`, `nazwa`, `logiczny`, `inny`, `calko1`, `calko2`, `rzecz`, `nic`, `pusty`. Czy twoje przypuszczenia się sprawdziły ?Zgodnie z powyższym przykłądem, wektor składa się z 4 elementów typu `character`, element "a"

**WAŻNE !!!** Operator przekazania wartości do zmiennej można utworzyć przy pomocy skrótu klawiszy **alt+myślnik**, czyli **(alt+-)**.

**WAŻNE !!!** Jeśli chcemy, aby zawartość zmiennej została wyświetlona w ekranie konsoli od razu po jej utworzeniu, musimy polecenie zamknąć w nawiasach okrągłych `(polecenie)`, np.:

```{r, eval=F}
(z <- 23)
```

***

## 3.2. Wektor

Wektor to uporządkowany zbiór obiektów tego samego typu. Do tworzenia wektora z pojedynczych elementów lub innych wektorów służy funkcja `c()`. W programie `R` nie ma rozróżnienia na pojedynczą wartość i wektor, pojedyncze wartości traktowane są jako jednoelementowe wektory.

Utworzymy pierwszy 4 - elemetowy wektor liczbowy.

```{r}
a <- c(1,2,3,4) ; a
```

Wektory w postaci sekwencji możemy tworzyć przy pomocy operatora tworzenia ciągów arytmetycznych `:`, np:

```{r}
a <- 1:4 ; a
```

Wektor może przechowywać każdy typ danych. Poniżej kilka przykłądów skłądających się z 3 poleceń, tworzenia, wyświetlania i sprawdzenia typu obiektu: 

```{r}
a <- c(1L, 2L: 3L, 4L) ; a  ; typeof(a)
a1 <- 1:4 ; a1 ; typeof(a1)
a2 <- 1.1:4.1 ; a2 ; typeof(a2)
```

W tym przypadku musimy zwrócić uwagę, że utworzone wektory `a`, `a1` i `a2` są typu `intiger` i `double`, ale wrzystkie są zaliczane do `numeric`. 

Wpisując liczby dozwolona jest notacja naukowa (np. 2.5e3 oznacza 2500). Separatorem miejsca dziesiętnego w programie R jest kropka. Wyróżnioną wartością jest `NaN` (to skrót rozwijający się w *ang. not a number*, czyli „nie liczba”). Ta wartość może pojawić się w wyniku wykonania niepoprawnego działania (np. próby logarytmowania liczby ujemnej). Literały `Inf` i `-Inf` oznaczają plus i minus nieskończoność.

```{r}
a <- c(2.5e3, 1.1e2, NaN, Inf, -Inf) ; a ; class(a) ; typeof(a)
```

Teraz utworzymy wektory wartości logicznych i znakowych

```{r}
a  <- c("a","b","b", "c")  ; a  ; typeof(a)
a1 <- c(TRUE, FALSE, T, F) ; a1 ; typeof(a1)
```

**UWAGA !!!** Zauważ, że nadpisaliśmy zmienną `a` i `a1`.

Wektory atomowe w R mogą przechowywać elementy jednego typu, natomiast często w wyniku w wektorze mogą pojawić się elementy innego typu. Wykonaj poniższe przykłady i odpowiedz na pytanie jaka jest hierarchia typów obiektów w R.

```{r}
a1 <- c(F, 1L, 2.2, "cztery") ; typeof(a1)
a2 <- c(F, 1L, 2.2) ; typeof(a2)
a3 <- c(F, 1L) ; typeof(a3)
```

Z godnie z powyższymi przykłądami, nie trudo zauważyć, że R nadaje typ obiektu w sposób, który umożliwia minimalizację strat informacji. Taki mechanizm nazywamy `uzgodnieniem typów`. Ta wiedza, będzie bardzo przydatna w trakcie wczytywania danych do programu R z plików zewnętrznych np. tekstowych.

Należy zwrócić uwagę, że wartość `F` jest interpretowana przez program R jako `0`, natomiast `T` jako `1`.

```{r}
(2==2)+3
(2>3)+1
```

Spodziewałeś się takiego wyniku ?. 

```{r}
TRUE + 3
FALSE + 1
```


Domyślny typ obiektu możemy zmienić. Korzystaj z funkcji zaczynającej się od `as.` i nazwy typu obiektu. Poniżej kilka przykłądów konwersji typu danych.

```{r, eval=F}
a <- 1:4 ; a
typeof(a)
typeof(as.double(a)) # funkcja w funkcji

a <- 1.1:4.1 ; a
typeof(a)
typeof(as.integer(a)) # zwraca wynik funkcji zewnętrznej

a <- c(TRUE, FALSE, TRUE) ; a
typeof(a) 
typeof(as.character(a))

a <- c(1,0,1,1,1,0) ; a
typeof(a)
typeof(as.logical(a))
```

Nalezy pamiętać, że stosowanie funkcji np `as.logical(a)` spowoduje, że na ekranie konsoli wyświetlą się przekonwertowane wartości wektora, ale typ obiektu `a` nie ulegnie zmianie. Zawsze trzeba nadpisywać obiekt. Wykonaj i przeanalizuj poniższy przykład.

```{r}
a <- c(1L,0L,1L,1L,1L,0L) # tworzymy wektor typu integer
a             # wyświetlamy obiekt na ekranie konsoli
as.logical(a) # konwersja 0 = FALSE, 1 = TRUE
typeof(a)     # sprawdzamy

# teraz poprawna składnia
a <- c(1L,0L,1L,1L,1L,0L) 
a <- as.logical(a) # konwersja z nadpisaniem 
a
typeof(a) # sprawdzamy 
```

Odwrócimy operacje konwersji:

```{r}
as.numeric(a)
as.integer(a)
as.double(a)
```

***

### 3.2.1. Funkcje tworzenia wektorów

Poznaliśmy już dwie metody tworzenia wektorów, tj: za pomocą funkcji `c()` oraz operatora `:`. W wielu przypadkach stosowanie pojedyńczo tych funkcji jest nie wystarczające, lub uciążliwe. Wykonamy kilka przykładów, ktore pozwolą wam zrozumieć mozliwość łaczenia funkcj. W wielu przypadkach efektywnym jest skorzystanie z funkcji generowania sekwensji `seq()` oraz funkcji replikacji `rep()`.

Utworzymy kilka wektorów przy pomocy funkcji `c()` i operatora ciagów arytmetycznych `:`. 

```{r}
a <- c(10,1:3,10) ; a  
a <- c(4:1, 1:4) ; a
c(a, c(1,4,5), 8:5)
c(a, c(TRUE, FALSE))
```

**Funkcja seq()** - Zacznijmy od uruchomienia pomocy dla funkcji `seq()` i zobaczmy na jej opis, dostępne argumenty funkcji i przykłady.

```{r, eval=F}
?seq()
```

W celu uruchomienia przykładów dla funkcji `seq()` skorzystamy z funkcji `example()`.

```{r}
example(seq()) ## ładuje do okna konsoli przyklady zastosowania
```


Zauważymy, że jest funkcją pakietu podstawowego `base`, który nie wymaga aktywacji poleceniem `library()`. Funkcja `seq()` składa się z podstawowych argumentów: **from**, **to**, **by**. Co oznacza od, do, krok. 

Utworzymy teraz sekwencję liczb:

* od 1 do 10 z krokiem 1, oraz  
* od 1 do 2 z krokiem 0.1.

```{r}
seq(from = 1, to = 10, by = 1) # integer
seq(from = 1, to = 2, by = 0.1) # real
```


Pisząc polecenie wygodnym jest często pomijanie nazw argumentów. Teraz wykonamy powyższe polecenia, ale stosując zapis uproszczony.

```{r}
seq(1,10,1) # zapis uproszczony, bez nazw argumentów
seq(10) # zapis uproszczony, z argumentami domyślnymi
seq(1,2,0.1)
```


Teraz powinieneś rozumieć działanie tej funkcji. Zauważ że nie zawsze musimy stosować nazwy argumentów, jeśli wprowadzamy je w odpowiedniej kolejności. A czasami wystarczy podanie ostatniej liczby sekwencji np.: (10) w celu wygenerowania sekwencji z krokiem domyślnym 1 i początekiem domyślnym równym 1.

Zgodnie z dokumentacją funkcji `seq()` zamiast argumentu `by` mozemy stosować argument `lenght.out`, który służy do określenia ilości elementów z których ma się składać sekwencją. Zastępuje on argument `by`. Utworzymy wektor w zakresie od 34 do 128 składa jacy się z n elementów. n to dowolna liczba całkowita.

```{r}
sek1 <- seq(from = 34, to = 128, length.out = 5)
sek1
sek1 <- seq(34, 128, length.out = 4)
sek1
```


W przypadku konieczności utworzenia malejącego ciągu numerycznego, korzystamy z operatora `-`:

```{r}
sek2 <- seq(100,1,-12)
sek2
```

Zauważ, że argumentami mogą być też zmienne, lub wyrażenia arytmetyczne:

```{r}
a <- 2 ; b <- 20    # tworzymy zmienne a i b
seq(a,b, len = b/a) # wykorzystujemy je do uruchomienia funkcji seq()
```


**Funkcja rep()** - funkcja ta replikuje istniejący wektor określoną ilość razy. Przyjmuje ona następujące argumenty:

 * `x` - wektor, kóry bedzie replikowany, 
 * `times` - ilość replikacji wektora `x`, 
 * `len` - długość wektora wyjściowego,
 * `each` - ile razy ma być powielony każdy element wektora 'x'

Poniżej kilka przykłądów zastosowania funkcji `rep()`:

```{r}
rep(1:4, times = 2) # powielamy 2 razy wektor
rep(1:4,2) # j.w.
rep(seq(4),2) #j.w. z seq()
rep(seq(4), len = 3) # tylko 3 elementy wektora bez powielania
rep(1:4, each = 2) # nie to samo,
```

Powyższe argumenty możemy stosować zamiennie lub łącznie, kolejność wykonywania działań jest taka, że najpierw wykonywane jest polecenie `each`, a następnie `times` lub `len`. Prześledźmy poniższy przykłąd:

```{r}
rep(1:3, each = 3) # każdy 3 razy
rep(1:3, each = 3, times = 2) # j.w, potem wektor 2 razy
rep(1:3, each = 3, times = 2, len = 9) # j.w. tylko zwraca 9 ostatnich elementów
```

Argument `len` nie tylko ucina, ale powiela również utworzoną sekwencje 

```{r}
rep(seq(3), each = 2, len = 4)  # len uciał 2 elementy
rep(seq(3), each = 2, len = 8)  # len dodał 2 elementy
```

Argument `times` pozwala na powielanie każdego elementu określoną ilość razy, ale w tym przypadku wartością argumentu jest wektor, a nie liczba

```{r}
rep(1:3, times = c(1,2,3))
rep(1:3, 1:3) # j.w. prościej
rep(1:3, 3:1) # odwrotnie
```

***

### 3.2.2. Wektory domyślne pakietu bas

Zanim przejdziemy dalej poznamy kilka tzw. domyślnych wektorów pakietu `base` z których będziemy później korzystać.

```{r}
letters # małe litery
LETTERS # duże litery
month.name # nazwy miesięcy
month.abb # skrócone j.w.
pi # 
```

***

Możemy oczywiściue stworzyć polskie nazwy miesięcy, ale jest to trochę bardziej skomplikowane.

```{r}
format(ISOdate(2000, 1:12, 1), "%B")
format(ISOdate(2000, 1:12, 1), "%b")
```

Funkcja `ISOdate()` generuje wektor daty, skłądajacy się z pierwszego dnia każdego miesiąca. 

```{r}
czas <- ISOdate(year = 2000, month = 1:12, day = 1)  
czas
```

Funkcja `format()` zmienia format wyswietlania na `"%B"`. 

```{r}
czas <- format(czas, "%B")  
czas
```

Więcej o formatowaniu daty znajdziesz w pomocy dla funkcji `strptime()`

***

##### Ćwiczenie 4 {.tabset .tabset-pills}
###### Treść 

Wygeneruj nazwy dni tygodnia, korzystając z pomocy funkcji `strptime()` oraz funkcji `format()` i `ISOdate()`.

###### Odp. 

```{r}
format(ISOdate(year = 2000, month = 1, day = 3:9), "%A")
format(ISOdate(year = 2000, month = 1, day = 3:9), "%a")  
```

#####

***

##### Ćwiczenie 5 {.tabset .tabset-pills}
###### Treść 

Utwórz po dwa wektory liczbowe i tekstowe i mieszane korzystając z funkcji `c()`, `seq()`, `rep()`, opratora `:`, oraz poznanych wektorów tekstowych. Jeden wektor powinien zawierać wartości losowe z wektora tekstowego (Funkcja `sample()`, sprawdźć w pomocy)   

###### Odp. 

Kilka przykąłdowych odpowiedzi:

```{r}
c(1,2,3,4,5:8)
c(seq(1,9,0.8), rep(c(8,3,75,21), len = 10))
c(1:4, seq(0.1,0.5, length.out = 7), rep(6:2), 3)
sample(x = letters, replace = F, size = 10)
```

#####

***

##### Zastosowanie sekwencji {.tabset .tabset-pills}
###### Treść 

1. Funkcją `exp()` policzmy eksponentę (eksponenta, inaczej funkcja wykładnicza, to bardzo szybko rosnąca funkcja matematyczna) z sekwencji. 
2. Następnie - wykorzystując funkcję `plot()` - narysujmy sekwencję i jej eksponentę. 
3. Zauważmy, że argumentem tej funkcji jest wektor, a ponieważ większość operacji w R jest wektoryzowana, funkcja exp() policzy eksponentę dla każdego elementu wektora sekwencja.

###### Wykonanie 

```{r}
sekwencja <- seq(0, 10, 0.1) # sekwencja liczb
poziom <- exp(sekwencja) # każdą liczby sekwencji(x) podnosimy do ^e

plot(x = sekwencja,   # wartosci osi x
     y = poziom,      # wartości osi y
     xlab="czas spędzony z R",           # etykieta x
     ylab="poziom Data Science we krwi") # etykieta y
```

Domyślnie utworzono wykres punktowy. Argumentem `type` możemy zmienić typ wykresu np. na liniowy `type = "l"`

```{r}
plot(x = sekwencja, y = poziom,
     xlab= "Czas z R", 
     ylab= "Poziom data Science we krwi",
     type ="l", 
     main = "Trochę jak wyprawa na Rysy od Słowackiej strony, ale warto")
```

#####

***

##### Ćwiczenie 6 {.tabset .tabset-pills}
###### Treść 

Skoro umiesz już tworzyć proste wykresy, to wykreśl kilka funkcji:

* dla pierwiastkowania wektora sekwencji
* sekwencja do potęgi drugiej
* sekwencja po potęgi czwartej
* logarytm naturalny sekwencji
* logarytm dziesiętny sekwencji
* silnia z sekwencji (`factorial()`)

###### Wykonanie 

```{r, eval=F}
sek <- seq(0, 10, 0.1) # sekwencja liczb

plot(x = sek[1:20], 
     y = sqrt(sek)[1:20], type = "b")

plot(x = sek, 
     y = sek^2, type = "l")

plot(x = sek, 
     y = sek^4, type = "p") 

plot(x = sek, 
     y = log(sek)) 

plot(x = sek, 
     y = log10(sek))

plot(x = sek, 
     y = factorial(sek)) 

```

```{r echo=FALSE}
sek <- seq(0, 10, 0.1) # sekwencja liczb
rbind(
  data.frame(sek = sek, typ = "sqrt()", obs = sqrt(sek)),
  data.frame(sek = sek, typ = "factorial", obs = factorial(sek)),
  data.frame(sek = sek, typ = "^2", obs = (sek^2)),
  data.frame(sek = sek, typ = "^4", obs = (sek^2)),
  data.frame(sek = sek, typ = "log()", obs = log(sek)),
  data.frame(sek = sek, typ = "log10()", obs = log10(sek))
  ) -> dane

ggplot(dane, aes(x = sek, y = obs, color = typ)) + 
  geom_line(size = 1.3) + 
  labs(x = "Wartości wektora sekwencji",
       y = "wartość funkcji(sekwencja)") +
  facet_wrap(~typ, 3, scales = "free_y") +theme_bw()

```


#####

***

### 3.2.3. Indeksowanie wektorów

Indeksowanie wektora jest niczym innym jak operacją filtorwania, czyli wybierania interesujacych nas wartości lub spełniającyh określony warunek. NajczeWście Wartości wybieramy wskazując ich indeksy. Wektor to ciąg elementów. Pierwszy z tych elementów ma indeks 1, kolejny 2, kolejny 3 i tak aż do ostatniego elementu. np.:

```{r}
wek <-  c("a", "b", "c", "d") # tworzymy wektor
wek # wyświetlamy
str(wek) # wyświetlamy własnosći
```

Zgodnie z powyższym wynikiem funkcji `str()`, wektor składa się z 4 elementów typu `character`, element `"a"` ma indeks 1, a element 'd' ma indeks 4.

Indeks ostatniego elementu to jednocześnie długość wektora. Można ją sprawdzić funkcją `length()`. Zbadajmy długość poznanego już przez nas wektora: 

```{r}
length(wek) ; length(letters) ; length(month.name)
```

Aby odwołać się do określonych indeksów wektora należy użyć operatora `[]`. Nosi on nazywę  **indeksator**. Wewnątrz nawiasów kwadratowych podaje się indeks elementu, do którego chcemy się odwołać. Kilka przykładów:

```{r}
LETTERS[1] # pierwszy element wektora
LETTERS[5] # piąty
LETTERS[26] # ostatni element wektora
LETTERS[length(LETTERS)] # j.w. ale za pomocą funkcji length
```

Teraz wygenerujemy wektor liczbowy i wykonamy kilka operacji wybierania pojedyńczych elmentów

```{r}
wek <- c(seq(2,28,2), seq(2,4,length.out = 6))
wek
length(wek) # Sprawdzamy długość wektora
wek[length(wek)] # wybieramy ostatni element wektora
wek[10] # wybieramy 10 element wektora
```

Odwołując się do wektorów, możemy podać indeks więcej niż jednej wartości. Zasada jest jednak taka, że indeksy muszą być wektorem. Do tego przydadzą nam się już poznane funkcje `seq()`,`c()`, `rep()` i operator `:`. Przykładowo, aby wybrać 6, 12 i ostatni element z wektora LETTERS musimy wpierw skonstruować wektor z tymi trzema indeksami. Można to zrobić na 3 sposoby.

```{r}
LETTERS[c(6,12,26)] 
LETTERS[c(6,12,length(LETTERS))]
a <- c(6,12,26)
LETTERS[a]
```

Wybierzmy teraz co drugi element wektora `letters` z pomocą funkcji `seq()`

```{r}
letters[seq(1,length(letters),2)]
```

Równoważnie można najpierw stworzyć wektor indeksów a następnie wykorzystać go do indeksowania wektora LETTERS.

```{r}
co_drugi <- seq(1,length(letters),2)
letters[co_drugi]
```


Aby wybrać więcej elementów z wektora wygodnie jest wykorzystać sekwencje, teraz zastosujmy sekwencje tworzone operatorem ciągu arytmetycznego`:`.


```{r}
LETTERS[1:10] # dziesięć pierwszych liter
LETTERS[c(1:5,21:26)] # pięć pierwszych i pięć ostatnich
```

Wiemy, że sekwencje wartości nie muszą być rosnące. Można je wykorzystać np. do tego by odwrócić kolejność elementów w wektorze. Wygenerujemy litery alfabetu w kolejności odwrotnej: 

```{r}
LETTERS[26:1]
letters[seq(26,1,-1)]
seq(26,1,-1) # j.w. tylko z funkcją seq()
```

Indeksowanie można wykonać również w drugą stronę, tzn. poprzez usunięcie elmentów które nas nie interesują.

```{r}
letters[-(1:20)] # 6 ostatnich elementów
```


Elementy wektora można również indeksować warunkiem logicznym. Operatory logiczne scharakteryzowalismy w **rozdziale 2.4**, jeśli już nie pamiętasz, to wróć tam na chwilę. Ten element nauki może być dla was trudny do zrozumienia na tak wczesnym etapie. Gdyby był z tym problem zachęcam wrócić do tego momentu po przerobieniu **rozdziału 3.2.4.**

Korzystając z operatorów logicznych możemy w łątwy sposób uprosćić procedurę filtorowania wybranych elementów wektora. Wektor wek skłąda się z `20` elementów i przechowuje wartości w zakresie od `2` do `28`. 

Wybierzmy z wektora `wek` liczby, które są większe od 20. Najpierw musimy zdefiniować polecenie logiczne, które utoworzy nam wektor wartości `TRUE` i `FALSE`

```{r}
wieksze_od_10 <- wek > 10
```

Teraz porównajmy wektor `wek` z wektorem `a`. 

```{r, eval=F}
wieksze_od_10 ; wek # porównujemy wartości, patrz tabela.
```

```{r, echo=FALSE}
knitr::kable(data.frame(wek, wieksze_od_10), caption = "Tabela 8. Porównanie wekotorów wek i a")
```

Zgodnie z tabelą wynikiem polecenia `wek > 10` jest wektor wartości logicznych, który zwraca odpowiednio wartości: 
* `TRUE` dla `> 10`,
* `FALSE` dla `<= 10`. 

Teraz wykonamy operacje indeksowanie wektorem `wieksze_od_10` i otrzmamy wektor, który zawiera wartości liczbowe większe od 10.

```{r}
wek[wieksze_od_10]
```

Możemy też skorzystac z uproszczonej formy:

```{r, eval=FALSE}
wek[wek > 10]
```

Gdy chcemy odwrócić operacje filtrowania, prostym sposobem jest skorzystania z operatora negacji `!`.

```{r, eval=FALSE}
wek[!wieksze_od_10]
```

W indeksowania możemy wykonywać również operacje bazujące róWnież na pozostałych operatorach relacyjnych `<,>,=!, ==, które pozanliście w poprzednim rozdziale.

Ostatnim, ale niezwykle waznym operatorem stosowanym w indeksowaniu jest operator `%in%`. Jest on przydatny gdy chcemy wybrać określone (znane) elementy wektora.

Utwórz najpierw wektor wartości: 

```{r}
wek2 <- rep(letters[1:5],3)
wek2
```

Chcemy wybrać wrzystkie elementy `a` i `c`. Możemy to zrobić na dwa sposoby, przy wykorzystaniu połączenia operatorów relacyjnych i logicznych:

```{r}
wek2[wek2 == "a" | wek2 == "c"] # wybierz a oraz c
wek2[wek2 != "b" | wek2 != "d"] # wybierz a oraz c
```

lub przy zastosowaniu operatora `%in%`

```{r}
wek2[wek2 %in% c("a", "b")] # wybierz a oraz c
```

Przy okazji indeksowania warto wspomnieć o dwóch ważnych funkcja, które są często stosowane w odniesieniu do wektorów liczb, tj.:`is.na()`, `na.omit()`.

Funkacj `is.na()` zwraca wektor wartości logicznych. Jeśli liczba to `FALSE`, jeśli `NA` to `TRUE`.

```{r}
wek1 <- c(1:2, rep(NA, 4), seq(6,7,0.5))
wek1
is.na(wek1)
```

Jeśli chcemy wybrać tylko elementy różne od `NA` to korzystamy z znaku negacji `!is.na(wek1)`.

```{r}
wek1[!is.na(wek1)] # liczby
wek1[is.na(wek1)] # NA
```

Innym sposobem jest działanie funkcją `na.omit()`, która usuwa wszystkie elementy oznaczone jako `NA`.

```{r}
na.omit(wek1) -> bez_NA
str(bez_NA)
```

***

##### Ćwiczenie 6 {.tabset .tabset-pills}
###### Treść 

Wykonaj każde poniższe polecenie dwoma metodami:

1. Zbuduj sekwencję odwrotną 6 kolejnych małych liter alfabetu łacińskiego, zacznij od z.
2. Zbuduj sekwencję 5 kolejnych liczb nieparzystych zaczynając od 3.
3. Z wektora LETTERS wybierz litery na pozycjach 5, 10, 15, 20 i 25.
4. Wypisz wartości wektora LETTERS od końca.

###### Odp. 

Zbuduj sekwencję odwrotną 6 kolejnych małych liter alfabetu łacińskiego, zacznij od z.
```{r}
letters[26:21] -> a ; a ; length(a)
letters[26:(26-5)]
letters[length(letters) : (length(letters) - 5)]  
```

Zbuduj sekwencję 5 kolejnych liczb nieparzystych zaczynając od 3.
```{r}
seq(3,15,2)
seq(3,3*5, length.out = 5)
```

Z wektora LETTERS wybierz litery na pozycjach 5, 10, 15, 20 i 25.
```{r}
LETTERS[c(5,10,15,20,25)]
LETTERS[seq(5,25,5)]
```

Wypisz wartości wektora LETTERS od końca.

```{r}
LETTERS[26:1]
LETTERS[seq(26,1,-1)]
```

####

***

### 3.2.4. Operacje wykonywane na wektorach

W rozdziale 2 poznałeś operatory arytmemytyczne. W ramach tego rozdziału nauczymy się je wykorzystywać w odniesieniu do wektorów. 

**Operacja na wektorach i liczbach**

Podstawowowym typem operacji jest: wektor - operator - liczba = wyniki. W tym przypadku operacje wykonywane są dla każdego elemente wektora. Operacja ta jest podobna do funkcji przeciągania w exelu. Zróbmy kilka przykładów.

```{r}
a <- c(1:4) # Tworzymy dwa wektor a
b <- seq(2,8,2) # Tworzymy dwa wektor b

a ; a+2 # wyświelt, wykonaj dodawanie
a ; a-2 
a ; a*2 
a ; a/2
a ; a^2
a ; a%/%2 # cz. całkowita
a ; a%%2 # reszta z dzielenia
```

**Operacje na równych wektorach**

Dobrze, teraz sprawdzimy jak są wykonywane operacje arytmetyczne na dwóch wektorach. W tym przypadku każdy element wektora jest mnożony, dodwany itd.. przez odpowiedni element wektora drugiego. Odpowiedni, tzn. znajdujący się w tym samym położeniu, lub o tych samych indeksach. Przyjrzyj się ponizsyzm przykłądom, by lepiej zrozumieć tą operację.

```{r}
a ; b ; a+b
a ; b ; a-b
a ; b ; a*b
a ; b ; a/b
a ; b ; a^b
```

**Wektory o róznych długościach**

W przypadku wektorów o róznych długościach stosowana jest tzw. reguła zawijania wektora. Oznacza to, że wektor krótszy jest powielany, aż wykona wrzystkie operacje na wektorze dłuższym. Przyjrzyjmy się przykładom.

```{r}
a <- seq(8)
b <- c(2,4)

a; b; b*a
a; b; b-a
a; b; b+a
a; b; b^a
```

Analogiczną operację, można wykonać stosując funkcje `rep()` dla wektora b.

```{r}
a <- seq(8)
b <- c(2,4)
b <- rep(b,4)

a; b; b*a
a; b; b-a
```


Tak, wyniki są identyczne. Mam nadzieje, że jest to już zrozumiałe. Teraz w ramach ćwiczenai spróbuja wykonać operacje arytmetyczne na wektorach, które składają sie z 2 elementów i 3 elementów. np. `a = 1:3`, `b = c(4,2)`. Zastanów się jak w tym pryzpadku zadziała **reguła zawiajania**.


**Operacje relacyjne**

Na wektorach mozemy oczywiście wykonywać róWnież operacje relacyjne, o czym już wspominaliśmy. W tym przypadku róWnież obowiązuje reguła zawijania. Wykonajmy kilka prostych przykładów.

```{r}
x <- c(1,5,7,5) # tworzymy wektory
y <- c(4,2,9,5)
```

```{r, eval=F}
x; y; x > y # czy mniejszy ?
x; y; x < y # czy większy ?
x; y; x <= y # czy nie większy ?
x; y; x >= y # czy nie mniejszy ?
x; y; x == y # czy równy ?
x; y; x != y # czy różny ?
```

Być może tabelaryczne zestawienie wyników, będzie czytelniejsze:

```{r, echo=F}
relacje <- data.frame(x,y,
                      czy_mniejszy     = (x >  y),
                      czy_wiekszy      = (x <  y),
                      czy_nie_wiekszy  = (x <= y),
                      czy_nie_mniejszy = (x >= y),
                      czy_rowny        = (x == y),
                      czy_rozny        = (x != y))
                      knitr::kable(relacje)
```


**operacje logiczne**

Zasady wykonywania operacji logicznych już znacie, więc tylko krtótkie przypomnienie z zastosowaniem do wektorów.

```{r}
a <- c(TRUE, FALSE, NA) # Tworzymy wektory wartości logicznych
b <- c(T, F, NA) # to samo, ale prosty zapis

a ; !a # ! negacja
b ; !b # ! negacja

T  |  b # | alternatywa
F  |  b # | alternatywa
NA |  b # | alternatywa

T  & a # & koniunkcja
F  & a # & koniunkcja
NA & a # & koniunkcja
```

Zwróć uwagę, że uwzgledniono wartość `NA`. Natomiast trzeba uważać z wykonywaniem operacji logicznych na wektoach liczbowych. Spróbojmy dodać, odjąć i pomnożyć wektor wartosci liczbowych, przez wektor wartości logicznych.

```{r}
a <- c(T, T, F, F, NA, NA)
b <- 1:6

a; b; a+b
a; b; a-b
a; b; a*b
a; b; a/b
```

Wynikiem są liczby, dlaczego ? Przyjrzyj się, poprzednim przykładom i zauważ że wartość logiczna `TRUE` w operacjach arytmetycznych z wektorem liczbowym działa jak `1`, a wartość `FALSE` przyjmuje `0`. Prostym przykąłdem udowodnienia tego jest wykonanie konwersji wektora wartości `logical` na typ `integer`.

```{r}
as.integer(a)
```

**Modyfikacje elementów wektora** 

Częstym przypadkiem jest wprowadzenie błędnych wartości w wektorze, czy zestawie danych, które są nieprawidłowe. W celu podmiany lub zmiany wybranych elmentów wektora korzystamy z wyrażeń modyfikacji wektora. 

```{r}
# tworzymy wektor
x <- seq(1,5,0.8) 
y <- 1:length(a)  
```

```{r}
# Podmieniamy 1-elemenet wektora
x[1] <- 1.2 ; x
# podmieniamy 6 element (ostatni)
x[6] <- 5.1 ; x
# j.w inny sposób
x[length(x)] <- 7 ;x
# podmieniamy 2-elementy, [2:3]
x[2:3] <- c(5,5) ; x
# podmieniamy 3 pierwsze elementy wektora x wekotem y
x[1:3] <- y[1:3]
x;y
x == y
# reguła zawijania, co podmieniamy za co ?
x
x[-(1:4)] <- 100
x
```

***

### 3.2.5. Funkcje działajace na elementach wektorach 

Operacje arytmetyczne na każdym elemencie wektora możemy wykonywać przy pomocy różnego rodzaju funkcji dostępnych w R. Wiele z tych funkcji omówilismy w ramach rozdziału 2.


```{r}
x <- seq(2,20,4) # tworzymy wektor
```

Teraz wykonamy eperacje pierwiastkowania, logarytmowania, podniesiemy do potęgi x. 

```{r}
x ; sqrt(x)
x ; exp(x)# funkcja wykładnicza każdy element e^x, a e=2.71
x ; log(x, 10)
```

Otrzymane wyniki mają wiele miejsc po przecinku, aby ograniczyć ich ilość skorzystamy z funkcji `round()`

```{r}
x ; round(log(x, 10),2)
```

W przypadku wektora wartości odatnich i ujemnych można wyliczyć wartości bezwględne elementóW wektora np.:

```{r}
x <- seq(-100,100,25)
x ; abs(x)
```

Pamietaj, że gdy stosujemy wiele funkcji operacje są wykonywane w określonej kolejności. Możemy również stosować w tym przypadku operacje indeksowania.= np.:


```{r}
x ; round(log(x[x>0], 10) * (3/2), 2)
```

Najpierw indeksowanie `[x>0]` większych od zera, potem logarymt dziesietnych z większych od zera `log(x,10)`, nastepnie mnożenie wyniku logarytmowania `*(3/2)` i na końcu zaokrąglenie wyniku do dwóch miejsc po przecinku `round(,2)`.

W określonych sytuacjach koniecznym jest uporządkowanie wartości liczbowych, np.: gdy chcemy określić charakterytykę naszego zbioru danych. Służa do tego funkcje `sort()` i `order()` 

Zanim zacznimy z nich korzystać posłużymy się prostą funkcją generowania wektorów liczb losowych `sample`. Funkcja ta na podstawie zadane wekrtora `x`, generuje wektor wartości losowych o okreslinej licznośc `size`. Możemy również określić, czy chcemy aby wartości wektora `x` były powtarzane lub nie `replace = T or F`. 

```{r}
a <- sample(x = 1:4,   # wektor x 
            size = 20, # liczność obserwacji wynikowego wektora
            replace = T) # powtarzaj 
a
```

Teraz korzystajć z funkcji sort()  utworzymy  wektory wartosci rosnących i malejacych

```{r}
sort(a) # rosnący
sort(a, decreasing = F) # j.w.
sort(a, decreasing = T) # malejący
```

***

### 3.2.6. Funkcje wektorów

Program R posiada wiele wbudowanych funkcji operujących na wektorach i pozwalajacych zwrócić określone wartości:

 * `max()` wartość maksymalna wektora
 * `min()` wartość minimalna wektora
 * `mean()` wartość średnia wektora
 * `median()` Mediana z wektora (wartość środkowa zbioru)
 * `sum()` wartość suma wektora
 * `prod()` iloczyn elementów wektora
 * `sd()` wartość maksymalna wektora
 * `var()` Wariancja

Do celów ćwiczenia wygenerujemy dwa 100-elementowe wektory
```{r}
a <- sample(x = 1:10, size = 100, replace = T) # powtarzaj 
b <- sample(x = c(1:5,NA), size = 100, replace = T) # powtarzaj 
```

Teraz na każdym wektorze przetestujemy powyższe funkcje.

```{r}
max(a) ; max(b)
```

Zauważ, że w przypadku wektora b otrzymaliśmy wartość `NA`, w przypadku tego typu wektora możemy zgodnie z naszą wiedzą usunąć wartości `NA`, podmienić je inną wartością liczbową, lub poprostu pominąć poprzez wykorzystanie argumentu `na.rm = T`

```{r}
max(a) ; max(b, na.rm = T) 
# lub
max(b[!is.na(b)]) # z indeksowaniem
# lub
b[is.na(b)]<- 6 # podmiana NA na 3
max(b) # podmiana
```

Argument `na.rm = T`, ma zastosowanie do wrzystkich wymienionych w tym rozdziale funkcji.

```{r}
b[b == 6]<- NA # powrót do NA
```

```{r}
max(a); min(a); mean(a); median(a); sum(a) 
prod(a) # ilosczyn
sd(a) # odch.stand.
var(a) #wariancja
```

Teraz na wektorze `b` z wartościami `NA`

```{r}
max(b, na.rm=T); min(b, na.rm=T); mean(b, na.rm=T); median(b, na.rm=T); sum(b, na.rm=T)

prod(b, na.rm=T)
sd(b, na.rm=T)
var(b, na.rm=T)
```

Istnieją róWnież bardziej wyrafinowane funkcje, które zwracają od razu większą ilość parametróW. Funkcja `range()` zwraca zakres danych, czyli max i min z wektora.

```{r}
range(a) ; range(b)
```

Charakterystykę próbki możemy określić również przy pomocy funkcji: `unique()`, `table()`, `summary()`.

Funkcja `unique()` zwraca wektor wartości unikalnych

```{r}
unique(a)
unique(b, na.rm = T)
```

Możemy to przedstawić w troszkę bardziej przyjemny dla oka sposób.

```{r}
sort(unique(a))
sort(unique(b, na.rm = T))
```

Funkcja `table()` zwraca informacje o liczności każdego elementu np.:

```{r}
a <- sample(seq(1,2,by = 0.1), size = 100, replace = T)
sort(unique(a))
sort(table(a))
```

Wynikiem jest wektor, w którym nazwy to unikalne wartosci wektora, a w drugiej kolumnie mamy liczność występowania każdej wartości. Najcześćie występowała wartość: 

```{r}
max(table(a))
```

najrzadziej wartość:

```{r}
min(table(a))
```

a liczność naszych obserwacji (ilość elmentów wektora to):

```{r}
sum(table(a)) ; length(a) ; sum(table(a)) == length(a)
```


Funkcja `table()` zwraca nam ilość poszczególnych obserwacji, co graficznie można przedstawić za pomocą histogramu. Histogram przedstawia liczność wartości każdego przedziału.

```{r , fig.align="center", fig.cap="Rys.X Histogram wektora a"}
hist(a, 
     main = "Mój pierwzy histogram",
     xlab = "Wartości wektora a",
     ylab = "częstość występowania wartości")
```

Oprócz liczności próbkę danych możemy scharakteryzować przy pomocy kwantyli, do tego celu służą dwie funkcje:

 * `summary()` - zwraca kwartyle, mediane oraz średnią
 * `quantile()` - zwraca określony kwantyl

Przetestujmy funkcje summary

```{r}
summary(a)
summary(b) # działa nawet na brakach danych NA
```

Zauważ, żę wynikiem funkcji są:

* minimum (pierwsz wartość zbioru danych)
* 1 kwartyl (poniżej tej wartości zanjduje się 25% obserwacji)
* mediane (poniżej i powyżej ttej obserwacji znajduje się 50 % obserwacji)
* średnią 
* 3 kwartyl (poniżej tej wartości znajduje się 75% obserwacji)
* maksimum (ostatnia wartość zbioru danych)

Powyższe wartości możemy przedstawić na prostym wykresie ramka wąsy:

```{r}
boxplot(a, horizontal = T, main = "Mój drugi wykres")
```

Wąsy to min i max, ramka to 1 i 3 kwartyl, a pogrubiona czarna linia to mediana.

Kolejną fukcją, która pozwoli nam przybliżyć charakterystykę liczbową naszej próbki jest funkcja `quantile()`.

```{r}
quantile(a) # analogia summary - bez średniej
```

Możemy również wybrać kwantyl, który chcemy policzyć. 

```{r}
quantile(a, probs = 0.25)
quantile(a, probs = c(0.25, 0.5))
```

Policzymy teraz decyle:

```{r, fig.align="c"}
quantile(a, probs = seq(0,1,0.1))
```

***

### 3.2.7. Funkcje generowania wartości losowych

Często bardzo przydatne są funkcje generowania wektorów wartości losowych. Możemy skorzystać z kilku funkcji, które generują zbior wartości o rozkładzie normalnym, o rozkładzie Poissona, czy Bernoulliego. Przedstawimu tylko dwie funkcje, pierwsza to `rnorm()` - generuje zbioró wartosci o rozkładzie normalnym, oraz funkcji `runif()`, która generuje wektor wartości losowych. 

```{r}
rk1 <- rnorm(n = 100) # podajemy tylko liczbe elementów wektora n
rk2 <- runif(n = 100, min =2, max = 5) # podajemy n, wartość min i max. 
```

```{r, fig.align="c"}
hist(rk1)
hist(rk2)
```

***

## 3.3. Listy

Lista. Podobnie jak wektor, lista to również uporządkowany zbiór elementów. W przeciwieństwie do wektora, elementy listy mogą mieć różne typy. Podobnie jak w przypadku wektora poszczególne elementy mogą mieć nazwy. Listy tworzy się zazwyczaj z użyciem funkcji `list()`. Wykonaj polecenie i przyglądnij się wynikowi.

```{r}
al <- list(imie=c("Jan","Tomasz"), nazwisko="Kowalski", 
           wiek=25, czyWZwiazku=T)
al
```

Lista skłąda się z 4 nadrzędnych elementów, tj. imie, nazwisko, itd.., Zaleta listy jest to, że może przechowywać różnego typu wartosci, np. `character`, `logical`, czy `numeric`.

***

##### ćwiczenie 7 {.tabset .tabset-pills}
###### Treść

Wykonaj listę charakterystyczną dla książki adresowej dostępnej np. smart fonie z którego korzystacie. Ma zawierać dane dla 3 osób:

* Nazwisko i Imię,
* Adres (dokładny - jakbyście wysyłali list),
* Numer telefonu prywatnego,
* Numer telefonu służbowego,
* Miejsce pracy i nazwa uczelni na której studiuje,
* Adres mailowy (prywatny i służbowy) 

Listę umieść w zmiennej o nazwie: kontak


Następnie wykonaj kilka poniższych poleceń oraz wyjaśnij co zwraca każde polecenie (wyjaśnienia umieść w skrypcie w postaci komentarzy)

* `length(kontak)`
* `is.vector(kontakt)`
* `is.atomic(kontakt)`
* `typeof(kontakt)`
* `class(kontakt)`
* `str(kontakt)`

###### odp.

```{r}
kontakt <- list(nazwisko = c("Borsuk", "Koliber", "Tygrys"),
                imie = c("Karol", "Eliza", "Anastazia"),
                kod_pocztowy = c("33-178", "30-877","30-854"),
                nr_budynku = c(5, 6, 2),
                nr_lokalu = c(85, 32, NA),
                woj = c("Opolskie", "Ślaskie", "Mazowieckie"),
                tel_pr = c(505359357, 505234234, 676888965),
                tel_sl = c(607000222, 611222333, 666999777) ,
                firma = c("EB", "KHK", "ZKM"),
                uczelnia = c("AGH", "PK", "AGH"),
                email = c("bk@agh.pl", "ke@agh.pl","ta@agh.pl")
)

kontakt
```

```{r}
length(kontakt) # lista zawiera 11 atrybutów
is.vector(kontakt) # tak 
is.atomic(kontakt) # nie atomowy
typeof(kontakt) # typ obiektu lista
class(kontakt) # obiekt klasy lista
str(kontakt) # struktura obiekty
```

#####

***

**Ciekawostka** 

Przy pomocy polecenia `data.frame()` przekształcimy obiekt typu lista na obiekt typu ramka danych. Oraz go wyświetlimy. 

```{r, eval=F}
View(books <- data.frame(kontakt))
```

To samo polecenie możemy wykonać stosując inny prostszy zapis, ale dłuższy.

```{r, eval=F}
books <- data.frame(al)
View(books)
```

O obiektach `data.frame()`, powiemy więcej w rozdziale 3.5:

***

### 3.3.1. Indeksowanie listy

Do elementów listy możemy się odwoływać jak do elementów wektora, korzystając z nazw poszczególnych pól lub z operatora [[]] (operator ten został wyjaśniony w rozdziale dotyczącym indeksowania). W poniższym przykładzie konstruujemy listę czterech obiektów różnych typów.

```{r}
al[1] # odwołanie do atrybutu listy
al[3]
```

Jeśli chcemy wykonywać operacje na obiekcie listy, to stosujemy podwójny indeksator `[[x]]` lub `$`

```{r}
al[[3]] * 2
al$wiek * 2
```

Jeśli chcemy odwołać się do konkretnej wartości:

```{r}
al[[1]][2]
```

Podwójny nawias odwołuje się do atrybutu listy, a kolejny zestaw nawiasów do wektora.

### 3.3.2. Modyfikowanie list

Znamy zasady indeksowania, to modyfikacje są analogiczne jak w przypadku wektorów. Podmienimy zawartość atrybutu wiek.

```{r}
al$wiek <- c(23,35,77,58)
al
al[[2]] <- c("Nowak","Kowalski", "Koper")
al
```

Listy możemy również scalać, służy do tego funkcja 

```{r}
l1 <- list(nowa = c(1:10))
l2 <- list(koniec = c(20:29))
lista <- c(l1,l2) 
lista
```

### 3.3.2. Operacja na listach

Tak jak poprzednio, możemy wykonywać dodowlne opercja na poszczególnych atrybutach listy, ale musimy się do nich odwołać poprzez indeksowanie.

Przeprowadzimy kilka znanych nam operacji, ale najpier utworzymy listę przy pomocy poznanych funkcji:

```{r}
nowa <- list(waga = sample(50:80, replace = T, size = 5),
             wiek = round(runif(5, 25, 77),0),
             wzrost = sample(150:190, size = 5))
```

Teraz chcemy policzyć, średnią wagę, wiek, wzrost.

```{r}
mean(nowa) # nie działa
```

Aby wykonać operacje musimy się odwołąć do każdego elementu listy.

```{r}
mean(nowa$waga)
mean(nowa[[2]]) # itd.
```

Odwoływanie się do każdego elementu listy bywa bardzo męczące. W celu wykluczenia tego problemu możemy skorzystać z funkcji `lapply` i sapply. Wykonuje ona operacje na każdym obiekcie. Składnia jest analogiczna, podajemy nazwę naszej listy, a następnie podajemy nazwę funkcji z której chcemy skorzystać. 

Rożnica jest taka, że wynikiem funkcji `lapply` jest dalej lista, a funkcji `sapply` jest wektor.

```{r}
lapply(nowa, mean) -> a ; a
sapply(nowa, mean) -> b ; b
```

Wykonuje również inne operacje

```{r, eval=F}
# Działą na funkcjach zwracających wektory
lapply(nowa, summary) -> a ; a # lista wektoróW
sapply(nowa, range) -> b ; b # ramka danych

# można odwrócić wartość liczby
lapply(nowa, "-") -> a ; a 

# można przeliczyć każdy element
lapply(nowa, sqrt) -> a ; a 
sapply(nowa, exp) -> b ; b 

# można stosować argumenty funkcji, ale bez nawiasów
sapply(nowa, quantile) -> b ; b 
sapply(nowa, quantile, prob = c(0.5,0.75)) -> b ; b # dodatkowy argument funkcji
```

***


## 3.4. Macierze

Macierze tworzy się zazwyczaj funkcją matrix(). Parametrami tej funkcji jest wektor inicjujący zawartość macierzy oraz dwie liczby określające wymiary macierzy. Macierz może składać się z liczb, napisów lub wartości logicznych. W poniższym przykładzie konstruujemy macierz o wymiarach 4x2 wypełnioną zerami.

```{r}
matrix(data = 0, nrow = 2, ncol = 4) 
```

```{r, eval = F}
# lub forma skrócona
matrix(0,2,4)
```

Drugi przykład macierzy z ciągiem arytmetycznym.

```{r}
matrix(1:6, nrow = 2, ncol = 3)
```

Trzeci przykład macierzy z sekwencją.

```{r}
matrix(seq(3,8,1), nrow = 3, ncol = 2)
```

Czwarty przykład z zastosowaniem funkcji c().

```{r}
x <- matrix(c(1,2,3,1:3,3:5), 3, 3)
x
x <- matrix(c(1,2,3,1:3,3:5), nrow = 3, ncol = 3)
x
```

Macierz składająca się z elementów tekstowych.

```{r}
a <- c("A","B","C","D")
xx <- matrix(a,2,2)
```

Funkcją `array()` można również konstruować macierze, ale większej liczbie wymiarów. Tym zagadnieniem nie będziemy zajmować się w ramach tego kursu. Jeśli będziesz potrzebował kiedyś wiecej informacji, to znajdziesz je w @gkagolewski2014programowanie oraz @biecek2008przewodnik.

***

#### ćwiczenie 8 {.tabset .tabset-pills}
##### Treść

Utwórz macierz: `matrix(1:6, nrow = 2, ncol = 3) -> xx` Następnie wykonaj następujące polecenia i wyjaśnij w komentarzach co one zwracają. 

##### odp.

```{r}
matrix(1:6, nrow = 2, ncol = 3) -> xx
length(xx)
is.vector(xx)
is.atomic(xx)
typeof(xx)
class(xx)
nrow(xx)
ncol(xx)
```

####

***

## 3.5. Ramki danych

Szczególnym typem obiektu jest ramka danych, nazywana również tabelą danych. Ramka danych jest zazwyczaj z tabelaryczną strukturą, której elementy w każdej kolumnie są tego samego typu, ale mogą różnić się typami pomiędzy kolumnami. Z tego powodu ramkę danych można traktować jak listę wektorów o tej samej długości, każdy wektor odpowiada jednej kolumnie. Ramki danych tworzy się zazwyczaj funkcją `data.frame()`. 

Ramka danych jest oprócz wektora jednym z najczęściej wykorzystywanych typów obiektów i poświęcimy jej dość sporo uwagi.

Poniżej konstruujemy ramkę danych składającą się z trzech trójelementowych zmiennych. Konstruujemy ramkę danych podając wartości dla każdej z kolumn.

```{r}
ramka <- data.frame(id = c(100,101,102), 
                    wiek = c(25,21,22),
                    wzrost = seq(170,190,10),
                    chlopiec = c(TRUE,TRUE,FALSE))
ramka
```
```{r, eval=F}
View(ramka)
```

Do kolumn ramki danych (które są wektorami) możemy odwoływać się tak, jak do elementów macierzy, a także tak jak do elementów list przy pomocy operatora `$` dostępu do pól obiektu klasy S4. 

```{r}
ramka$wiek
```


***

### 3.5.1. Przygotowanie danych

Zanim przejdziemy do następnego tematu, musimy wczytać dane. Temu procesowi poświęcimy znacznie więcej uwagi w innym rozdziale.

```{r eval=FALSE, include=FALSE}
data.frame(imie = c("Katarzyna", "Zofia", "Julia", "Kora", 
                    "Piotr", "Adam", "Robert", "Janusz", "Beata"),
           Nazwisko = c(rep("Kowalska",3), "Nowak", "Zwykły", "Nowy", "Nowy", "Ptak", "Ptak"),
           praca = c("AGH", "ZUS", "NFZ", "AGH", "PK", "UJ", "UG", "NFZ", "UMK"),
           stanow = c("asystent", "księgowy", "księgowy", "adniunk", 
                      rep("prof.",3), "technik", "Inżynier"),
           Zarobki = round(runif(n = 9, 2000, 6000),1),
           staz = round(runif(9, 5,20)),
           urlop = round(runif(9, 1,26)),
           Waga = round(runif(n = 9, 50, 110)),
           Wzrost = round(runif(n = 9, 150, 190)),
           Wiek = round(runif(n = 9, 27, 65)), 
           Plec = sample(c("M", "K"), size = 9, replace = T),
           Kraj = sample(c("PL", "USA", "DE"),size = 9, replace = T),
           urodzony = c("Tarnów", "Gorlice", "Sękowa", "Kraków", "Berlin", 
                        "Amsterdam", "Brzesko", "Wieliczka", "Skawina")
) -> dane
dane
toString(colnames(dane))
colnames(dane) <- c("imie", "nazwisko", "praca", "stanow", "zarobki", "staz", 
                    "urlop", "waga", "wzrost", "wiek", "plec", "kraj", "urodzony")
save(dane, file = "dane.RData")


```

W folderze który pobrałeś z [upel](http://upel.agh.edu.pl/wggiis/) znajduje się plik `dane.RData`.

Sprawdzć, czy masz odpowiedni obszar roboczy.

```{r, eval=F}
getwd()
```

Jeśli nie to poleceniem `setwd("...")` ustaw go na folder w którym znajduje się plik z danymi, *gdzie 3 kropki to ścieżka dostępu*.

Poleceniem `dir()` sprawdzć jakie plki i foldery znajdują się w twoim katalogu.

```{r, eval=F}
dir()
```

Jeśli jest tam plik `dane.RData`, to wykonaj polecenia ładowania.

```{r}
load(file = "dane.RData")
```

W prawym górnym oknie powinien pojawić się obiekt `dane`, który ma następującą postać:

```{r}
dane
```

***

### 3.5.2. Własności obiektu data.frame

W ramch cwiczenia 9 zaznajomiłeś się z charakterystyką obiektu `data.frame()`. W tym rozdziale, krótko przedsatwię kilka funkcji pozwalajacych nam lepiej przyjrzeć się zawartości naszego obiektu.

W rmach tego rozdziału poznamy funkcje:

* `nrow()` - liczba wierszy
* `ncol()` - liczba kolumn
* `dim()` - liczba wierszy i kolumn
* `head()` - podglad kilku pierwszych wierszy
* `tail()` - podgląd kilku ostatnih wierszy
* `View()`, - wyświetl obiekt 

W pracy z dużymi zbiorami danych przydją się funkcje zwracająca nformacje o liczbie wierszy i kolumnw w obiekcie `data.frame`:

```{r}
# Liczbę wierszy można sprawdzić funkcją nrow() 
nrow(dane)
#liczbę kolumn sprawdzamy funkcją ncol(). 
ncol(dane)
# naraz
dim(dane)
```

Wartym uwagi jest również możliwość pozyskania informacji o nazwach kolumn i wierszy obeiektu `data.frame()`

```{r}
colnames(dane)  # nazwy kolumn
names(dane)     # j.w
row.names(dane) # nazwy wierszy
```

W łątwy sposób informacje o charakterystyce danych mozemy otrzymać wykonując polecenie `summary()`:

```{r, eval=F}
summary(dane) 
```

Szczególnie zalecam stosowanie funkcji `str()`, która zwraca nam w bardzo przystępny sposób charakterystykę całego obiektu:

```{r, eval=F}
str(dane)
```

Tak, mamy obiekty tupy `factor()`, ale o tym póżniej.

Poleceniem `head()` i `tail()` możemy wyświetlić podgląd wybranych danych, aby im się przyjrzeć.

```{r, eval=FALSE}
head(dane) # 6 pierwszych
tail(dane) # 6 ostatnich
```

Możemy określić ilość wierszy, która chcemy wyświetlić.

```{r, eval=FALSE}
head(dane, 3) # 3 pierwsze
tail(dane, 3) # 3 ostatnie
```

Lub wyświetlić cały zestaw danych

```{r, eval=F}
View(dane)
```

***

#### ćwiczenie 9 {.tabset .tabset-pills}
##### Treść

Stwórz dowolną tabele składająca się 10 wierszy i 4 kolumn. Pod zmienną `dane`. W kolumny od 1 do 4 mają przechowywać odpowiednio. 

* liczby całkowite
* liczby rzeczywiste (do dwóch miejsc dzietnych)
* tekst
* zmienne logiczne
* Kolumny mają mieć też określone nazwy. Nazwy dowolne, ale krótkie (jedno słowo do 5 znaków).

wykonaj następujące polecenie dla obiektu dane oraz opisz co zwracają w komentarzach.

```{r, eval=F}
length()
is.vector()
is.atomic()
is.data.frame()
is.array()
str(attributes())
typeof()
class()
```

##### odp.

Stwórz dowolną tabele składająca się 10 wierszy i 4 kolumn. Pod zmienną `dane`. W kolumny od 1 do 4 mają przechowywać odpowiednio. 

* liczby całkowite , 
* liczby rzeczywiste (do dwóch miejsc dzietnych)
* tekst
* zmienne logiczne
* Kolumny mają mieć też określone nazwy. Nazwy dowolne, ale krótkie (jedno słowo do 5 znaków).

```{r}
data.frame(calko = c(1:10),
           rzecz = seq(0.8,20, length.out = 10),
           tekst = letters[sample(1:26, replace = T, size = 10)],
           logic = as.logical(rep(0:1), 5)
           ) -> dane 
dane ; View(dane)
```


wykonaj następujące polecenie dla obiektu dane oraz opisz co zwracają w komentarzach.

```{r}
length(dane)
is.vector(dane)
is.atomic(dane)
is.data.frame(dane)
is.array(dane)
str(attributes(dane))
str(dane) # bardzo pomocne
typeof(dane)
class(dane)
```

Zauważ, że w zależności od typu danych zawartych w kolumnie funkcja summary zwraca różne informacje.
Pamietasz funkcje `table()`. Porównaj wyniki z funkcją `summary()`

```{r}
table(dane$tekst)
```

####

***

###  3.5.3. Indeksowanie

Aby odwoływać się do wierszy lub kolumn ramki danych można wykorzystać operator [,]. Ważny jest przecinek, ponieważ rozdziela nam ideksator na wiersze i kolumny. `obiekt[wiersze,kolumny]`. Przecinek nie zawsze jest ważny, ale o tym pózniej.

***

**Filtrowanie wierszy w ramce danych** - Filtrowanie wierszy jest podstawową operacją wybiernia podzbioru danych z ramki danych. Jest ona przydatna, gdy interesuje nas tylko część zbioru danych, lub niektóre wwiersze zawierają zbędne informacje.

```{r}
load("dane.RData")
```

```{r}
dane[1,] # pierwszy wiersz
```

Jeżeli chcemy wybrać więcej niż jeden wiersz należy, podobnie jak dla wektorów, podać kilka indeksów przed przecinkiem. Aby odwołać się do kilku kolejnych wierszy można wykorzystać sekwencję zbudowaną z operatorem. Przykładowo, wiersze od 5 do 7 z ramki danych `dane` można wyłuskać następująco.

```{r}
dane[5:7,]
```

Funkcja `c()` skleja wartości i sekwencje w wektor, który można następnie wykorzystać w indeksowaniu wierszy. Poniższa instrukcja wyłuskuje wiersze 2, 3, 7 i 9.

```{r}
dane[c(2:3,7:9) , ]
```

Lub równoważnie:

```{r}
indeksy <- c(2:3,7:9)
dane[indeksy,]
```

Jako indeksy można również wykorzystać wektor wartości logicznych. Wybiegając trochę w przyszłość, użyjemy kolumny waga aby wybrać z ramki danych tylko te wiersze, dla których waga jest wyższa niż 60.

```{r}
ciezkie <- dane$waga > 60 # operator relacji
ciezkie # wyniki logical
```

Teraz wektorem logicznym wybierzemy wiersze, `TRUE` - wybierz wiersz, `FALSE` - pomiń wiersz

```{r}
dane[ciezkie, ] # waga większa od 60
```

Indeksując wiersze lub kolumny można też wykorzystywać ujemne indeksy. Oznaczają one, wszystkie wartości poza wskazanymi. Przykładowo, wszystkie wiersze poza 1, 3, 5, 7, 9 można uzyskać poleceniem.

```{r}
dane[ -seq(1,9,2), ]
```

Zauważmy, że w tym przykładzie operator arytmetyczny minus `-` przed funkcją `seq()` tworzącą wektor, powoduje zmianę znaku wszystkich elementów wektora.

```{r}
-seq(1,9,2) 
-c(1,2,3)
-5:3 # uwaga
-5:-3
```

**UWAGA!!!** Nie można mieszać jednocześnie indeksów dodatnich i ujemnych.

```{r, eval=F}
dane[c(-4:-2, 8, 9),] # błąd
```

***

**Selekcja kolumn w ramce danych** - Zacznijmy od prostego przykładu: 

```{r}
dane[1]
```

Wybranie jednej kolumny powoduje, że jako wynik otrzymujemy nie ramkę danych ale wektor. Łatwo to poznać po sposobie wyświetlania danych.

Próba indeksowania w sposób analogiczny jak wykonywane było to dla wektora pozwoliłą wyselekcjonować dane dla kolumny pierwszej. MOżna to zrobić również w z wykorzystaniem operatora `$`:

```{r}
dane$imie
```

Ta druga metoda odrazu wyświetla nam wywołąnie funkcji `levels()` czyli informacje o niepowtarzajacych sie obiektach. Wykonajmy teraz operacje selekcji kolumny stanowisko `Kraj`:

```{r}
dane[12] # metoda 1
dane$Kraj # metoda 2
levels(dane$Kraj) # tylko unikalne
unique(dane$Kraj) # działa j.w. 
```

Dzieje się tak dlatego, bo nasz obiekt jest typu `factor()`, czyli cyznnikowe, lub inaczej wyliczeniowego. O cyzm powiemy sobie później więcej. 

```{r}
class(dane$imie)
```

Podobnie jak wiersze, można indeksować również kolumny. Aby wyłuskać drugą kolumnę można wskazać jej numer po przecinku. Uwaga Ten dziwny zapis jest konsekwencją tego, że operator [,] jest w gruncie rzeczy funkcją. Więcej o zaawansowanych elementach języka dowiemy się w kolejnych odcinkach.

```{r}
dane[,2]
```

Aby zapobiec konwersji na wektor i jako wynik wciąż mieć ramkę danych, należy dodać do operatora indeksowania argument `drop=FALSE`.

```{r}
dane[,2, drop=FALSE]
```


W ramce danych kolumny możemy indeksować nie tylko numerami ale również nazwami (kolumny są nazywane). Aby wyłuskać z ramki danych kolumnę o nazwie waga możemy użyć tej `nazwy kolumny` jako `indeksu`.


```{r}
colnames(dane) # nazwy
dane[, "praca"]
```

Aby wybrać więcej niż jedna kolumnę, podobnie jak w przypadku wierszy i wektorów można wykorzystać funkcję `c()`. Przykładowo, jeżeli chcemy wybrać 1, 2, 11 i 12 kolumnę możemy użyć instrukcji.

```{r, eval=F}
# równoważnie moglibyśmy napisać
dane[, c("imie", "nazwisko", "plec", "kraj")]
dane[ ,c(1,2,11:12)]
kol <- c(1,2,11:12)
dane[,kol]
```

```{r}
kolumny <- c("imie", "nazwisko", "plec", "kraj")
dane[, kolumny] # j.w.
```

***

**Wybieranie pod ramki danych**

Możemy jednocześnie odwoływać się do wierszy i kolumn w ramce danych, wybierając jej podramkę. Przykładowo, 

```{r}
# wybór czterech wierszy i czterech kolumn lub 
dane[c(1:4), c(1:4)]
#wybór czterech wierszy i jednej kolumny lub 
dane[c(1:4), 2]
#Jeden wiersz i cztery kolumny może wyglądać taki.
dane[1, c(9:12)]
```

Pokazaliśmy wcześniej, jak można odwoływać się do kolumn poprzez ich nazwy. Podobnie można zrobić z wierszami. Funkcja rownames() pokazuje jak nazywają się wiersze w ramce danych. 

```{r}
rownames(dane)
```

Te nazwy niewiele mówią, używanie ich do indeksowania nie miałoby sensu. Zmieńmy więc nazwy wierszy na takie jak w kolumnie imie. Robimy to przez nadpisanie zmiennej wyniku funkcji `rownames()`. Najpier jednak zmienimy typ kolumny imie z factor na character.

```{r}
dane$imie <- as.character(dane$imie) # konwersja typu z nadpisaniem
rownames(dane) <- dane$imie # podmiana nazwy wierszy
dane[,3:6] # podgląd
```

Poniższy przykład wybiera wiersze dla czterech wskazanych miejsc urodzenia oraz trzy wybrane kolumny. Jeżeli wiersze mają sensowne nazwy, to wygodniej jest odwoływać się do wierszy przez nazwy niż przez indeksy liczbowe.

```{r}
dane[c("Zofia","Julia", "Robert", "Piotr"), 
           c("waga", "wiek", "wzrost")]
```

Poniższym poleceniem przypisujemy spowrotem liczbowe nazwy wierszy jako liczbowe

```{r}
rownames(dane) <- NULL
dane[,3:6] # podgląd
```

Analogiczną metodą można zmienić nazwy kolumn:

```{r, eval=F}
colnames(dane) <- c("tu wpisać nowe nazwy kolumn")
# lub
colnames(dane)[1:3] <- c("zmienisz tylko pierwsze trzy nazwy")
```

**Sortowanie przez indeksowanie**

Interesujące i nieco zaawansowane zastosowanie indeksowania przedstawimy na przykładzie funkcji `order()`. Wynikiem tej funkcji, są indeksy kolejnych, rosnących wartości. Przykładowo, w kolumnie wzrost mamy następujące wartości


```{r}
dane[,"wzrost"]
```

Wynikiem funkcji `order()` są indeksy kolejnych, wartości. Najmniejsza wartość to 157, na pozycji 6, kolejna to 161 na pozycji 2, kolejna to 164 na pozycji 1 i tak dalej.

```{r}
order(dane[,"wzrost"])
# Równoważnie
order(dane$wzrost) ; dane$wzrost
```

Zwróć uwagę na składnie, `order()` jest funkcją nadrzędną. 

Możemy wykorzystać ten wynik, aby posortować ramkę danych po określonej kolumnie. W przykładzie poniżej wykorzystujemy funkcję `order()` do wyznaczenia wektora kolejnosc. Który następnie wykorzystamy do indeksowania ramki `dane`.

```{r}
kolejnosc <- order(dane[,"wzrost"])
dane[kolejnosc, c(1:2,7:9)]
```

Na koniec przykłąd z operatorem logicznym `&` koniunkcji. Wybierzemy na raz wrzystkie wiersze spełniajace dwa warunki.

```{r}
dane[dane$plec == "K" & dane$waga < 70, ] # 
```

***

### ćwiczenie 10 {.tabset .tabset-pills}
#### Treść

Wybierz z ramki danych dane

* wszystkie wiersze poza "AGH’’.
* wiersze "Kowalska"" 
* tylko kolumnę z wagą i wzrost.
* wszystkie kolumny poza ostatnią.
* wiersze dla których waga jest mniejsza niż 70 oraz cztery pierwsze kolumny.

#### odp.

wszystkie wiersze poza "AGH’’.

```{r}
dane[dane$praca == "AGH",]
```

wiersze "Kowalska"" 

```{r}
dane[dane$nazwisko == "Kowalska",]
```

tylko kolumnę z wagą i wzrost.

```{r}
dane[,c("waga", "wzrost")]
```

wszystkie kolumny poza ostatnią.
```{r}
dane[,-ncol(dane)]
```

wiersze dla których waga jest mniejsza niż 70 oraz cztery pierwsze kolumny + kolmna waga.

```{r}
dane[dane$waga < 70, c(1:4,8)]
```

####

***



***

### 3.5.4. Operacje arytmetyczne na data.frame()

Na ramkach danych możemy wykonywać wiele operacji obliczeniowych. W tym podrozdziale zaprezentujemy kilka prostych przykładów:

rozwiąż równanie $$wskaźnik=\frac{X}{\overline{x}}$$ 

gdzie: x - waga, a $\overline{x}$ - średnia waga

```{r, eval=FALSE}
wskaznik <- dane$waga/mean(dane$waga)
```

Chcemy mieć nasz wskaźnik w obiekcie `data.frame()`, możemy w łatwy sposób dodać dodatkową kolumnę:

```{r}
dane$wskaznik <- dane$waga/mean(dane$waga)
```

Na powyższym obiekcie możemy wykonać dowolne operacje arytmetyczne, relacyjne, czy stosując operatory logiczne.

***

**Funkcją aggregate()** - możemy stosować podsumowania danych w ramkach danych z podziałem na grupy, ale musimy posiadać obiekty typu `factor()`.

* `aggregate()`
* `by()`
* `taplly()`

Sprawdzamy czy mamy kolumnę typu `factor()` czynnik.

```{r, eval=F}
str(dane)
```

Mamy 6 kolumny typu factor, oraz 7 typu numeric i jedną character. Teraz wyliczymy średnie zarobki w każdym kraju:

```{r}
aggregate(dane$zarobki,       # kolumna uśrednia 
          list(kraj = dane$kraj), # grupowanie wg.
          FUN = mean)             # srednia
```

Obliczymy sumaryczne zarobki w grupie płeć, ale stosując prostszy zapis

```{r}
aggregate(dane$zarobki,list(plec = dane$plec), sum)
```

Inna funkcja to `by()`

```{r}
sredni <- by(dane$zarobki, dane$plec, FUN=mean) 
sredni
```

Wymaga konwersji do obiektu list, i data.frame:

```{r}
sredni 
sredni <- as.list(sredni)
as.data.frame(sredni)
```

I jeszcze funkcja `tapply()`

```{r}
tapply(dane$zarobki, dane$plec, mean) # średnia w grupach
```

***

### 3.5.5. Wybrane funkcje dla obiektu data.frame() 

Poleceniem data.frame możemy dodawać dodatkowe kolumny:

```{r}
dane$typ <- c(seq(1,7,1), NA, NA) # wymierzony
dane$rodzaj <- c(TRUE, FALSE, FALSE) # reguła zawijania
```

```{r, eval=F}
dane
```


Usuniemy dodane kolumny

```{r, eval=F}
dane[,-nrow(dane):-(nrow(dane)-3)]
colnames(dane) ; ncol(dane) # sprawdzamy
```

Do wykonywania operacji dodawania kolumny i wierszy wygodnym jest stosowanie funkcji `cbind()` i `rbind()`. Utworzymy najpierw dwa obiekty `data.frame()`


```{r}
a <- data.frame(las = runif(5, 0, 5),
                lit = sample(LETTERS[1:3], size = 5, replace = T))

b <- data.frame(las = runif(5, 0, 3),
                lit = sample(LETTERS[4:8], size = 5, replace = T))
a ; b
```

Poleceniem `rbind()` możemy scalić obydwie kolumny w jedną, bo mają takie same nazwy kolumn.

```{r}
rbind(a,b) -> nowy
nowy
```

Możemy dodac również jeden dowolny wiersz:

```{r}
rbind(a, c(10.1, "A"))
```

Funkcją `cbind()` dodajemy dodatkowe kolumny, lub

```{r}
cbind(a,b) # doda prefiks do nazwy kolumny
```

Teraz dodamy jedną kolumne z zastosowanie reguły zawijania.

```{r}
cbind(a, logiczna = c(T,T,F,F,F))
```

Możemy dodać dowolną ilość kolumn.

```{r}
cbind(a, 
      logarytm = log(a$las),
      pierw = sqrt(b$las),
      nowa = seq(0,20, length.out = 5))
```

lub, może bardziej czytelnie

```{r}
logarytm <-  log(a$las)
pierw <-  sqrt(b$las) 
nowa  <-  seq(0,20, length.out = 5) 
logarytm ; pierw ; nowa
cbind(a, logarytm, pierw, nowa)
```

***

# 4. Wczytywanie danych

***

## 4.1. Operacje na plikach i katalogach

Zanim zaczniemy wczytywać i zapisywać dane warto zapoznać się wstępnie z kilkoma funkcjami pakietu base, które służą do wykonywania operacji na plikach i katalogach. Najpierw przypomnienie dotyczące ustawienia katalogu domyślnego.

Teraz możemy wczytywać dane znajdujące się w katalogu domyślnym bez konieczności podawania pełnej ścieżki dostępu do pliku z danymi. Teraz sprawdzimy zawartość katalogu domyślnego. Mamy dwie opcje:

```{r}
getwd() ## zwraca informacje o aktualnym katalogu domyślnym
setwd("...") ## ustawia katalog domyślny 
```

Możemy zajrzeć do prawego dolnego okna Rstudio (zakładka Files) lub wpisać polecenie:
```{r, eval=F}
dir()
list.files() # j.w.
```

Korzystając z tego polecenia możemy otworzyć bardzo przydatny wektor, który można zastosować np.: w przypadku wczytywania danych z wielu plików danych. Utworzymy teraz wektor o nazwie pliki.

```{r, eval=FALSE}
pliki <- dir()
pliki
```

***

**Wykaz i opis wybranych funkcji** 

* `file.create(...)` - Funkcja tworzy pliki o zadanych nazwach, jeżeli takie pliki istnieją, to ich zawartość jest kasowana.
* `file.exists(...)` - Funkcja sprawdza czy pliki o zadanych nazwach istnieją.
* `file.remove(...)` - Funkcja usuwa pliki o zadanych nazwach (patrz też funkcja `unlink()`).
* `file.rename(from, to)` - Funkcja zmienia nazwę pojedynczego pliku.
* `file.append(file1, file2)` - Funkcja dokleja plik o nazwie file2 do pliku file1.
* `file.copy(from, to, overwrite=FALSE)` - Funkcja do kopiowania pliku z `from` w pozycje wskazaną przez argument `to`.
* `file.symlink(from, to)` - Funkcja do tworzenia linków symbolicznych (pod Unixami).
* dir.create(path, showWarnings=TRUE, recursive=FALSE) - Funkcja do tworzenia katalogów. Wynikiem tej funkcji jest wartość TRUE, jeżeli operacja utworzenia katalogu została wykonana pomyślnie. Jeżeli dany katalog już istnieje lub nie udało go się utworzyć funkcja przekazuje wartość FALSE.
* `file.info(...)` - Wynikiem tej funkcji są informacje o wskazanych plikach.
* `file_test(op, x, y)` - Funkcja do testowania plików. Dostępne testy to: jednoargumentowe (tylko x jest używane) op="-f" istnieje i nie jest katalogiem, op="-d" istnieje i jest katalogiem oraz dwuargumentowe op="-nt" jest młodszy niż (pod uwagę brane są daty modyfikacji) i op="-ot" jest starszy niż.
* `file.show(...)` - Funkcja wyświetla w oknie R zawartość jednego lub większej liczby plików.

***

**Przykłady**

W katalogu tematu drugiego powinienieś mieć dwa pliki tekstowe `im1.txt` oraz `im2.txt`. Otwórz je w notatniku, lub notepad++. Postaraj się by okno katalogu było otwarte. 

```{r, eval=F}
file.create("im3.txt")
file.create("im4.txt")
dir()
file.info("im1.txt")
file.info("im3.txt")
file.exists("im3.txt")
file.remove("im3.txt")
dir()
file.rename(from = "im4.txt", to = "im3.txt" )
dir()
file.remove("im3.txt")
file.append("im1.txt", "im2.txt")
## Teraz podglądnij w notatnik zawartość pliku im1.txt
file.copy(from = "im1.txt", to = "im3.txt", overwrite=FALSE)
dir.create("Twoje_Nazwisko", showWarnings=TRUE, recursive=FALSE)

```

***

## 4.2. Wczytywanie danych

W tym rozdziale omówimy metody wczytywania danych. Jest to dość proste i intuicyjne jednak wymaga znajomości rozszerzeń i typów plików. Jeśli wymienione w poniższym przykładzie rozszerzenia plików, programy nie są Państwu znane zachęcam do poczytania o nich. Akurat w tym wypadku Wikipedia jest wystarczającym źródłem informacji.

Dane mogą być przechowywane w najróżniejszych formatach, takich jak: 

* baza danych (Postgress, MySQL, Oracle), 
* plik tekstowy (.txt, .csv), 
* plik w formacie programu Excel (nowszym .xslx lub starszym .xls) 
* lub plik w formacie innego programu do analizy danych (SAS, SPSS, Statistica, itp).

W tym rozdziale odpowiemy na kilka zasadniczych pytań:

* Jak wczytywać dane tabelaryczne z plików tekstowych?
* Jak wczytywać dane tabelaryczne z plików Excela [xls lub xlsx]?
* Jak wczytywać dane z pakietów R?

Zawartość tego rozdziału nie jest wystarczająca, w przyszłości napewno będziecie korzystać z wielu różnych formatóW danych. Podstawowe informacje znajdziecie w rozdziale 3.1. [Przewodnik po pakiecie R 4.0](http://pbiecek.github.io/Przewodnik/). Bardzo prostym rozwiazaniem jest skorzystanie z wyszukiwarki google, gdzie wpisując np.: read shp in R, znajdziesz sporo informacji o wczytywaniu danych przestrzennych.

*** 

### 4.2.1. Dane w plikach tekstowych

Jednym z częstszych formatów używanych do przechowywania i wymiany danych są pliki tekstowe. Nazwa ‘plik tekstowy’ bierze się stąd, że treść tego pliku możemy otworzyć w standardowym edytorze takim jak Notepad/Notatnik w Windowsie lub vim w Linuxie/OSX. Pliki tekstowe można również otwierać z użyciem programu RStudio (uwaga, duże pliki mogą się długo otwierać). Jeżeli często pracujemy z dużymi lub wieloma plikami tekstowymi to warto wyposażyć się w dobre narzędzie do pracy z nimi, np. edytor Sublime Text i Notepad++.

Otwórz plik: `dane1_srednik.txt`

* pierwszy wiersz to nagłówek - zawiera nazwy kolumn rozdzielane średnikiem
* kolejne wiersze przedstawiają dane w postaci wektora wartości, które są rozdzielane znakiem `;`,
* w pliku występują liczby, które nie są liczbami całkowitymi - separatorem dziesiętnym jest znak `.`.

```{r}
getwd()
setwd("dane/") # wchodzę do foldera dane
getwd()
dir()
```

Instrukcja wczytująca dane do R składa się zazwyczaj z trzech członów. Ostatnim (po prawej stronie na poniższym schemacie) jest funkcja, która odczytuje dane, przetwarza i zamienia na postać zrozumiałą dla programu R.

Do wczytywania danych z pliku tekstowego posłużyć może funkcja `read.table()`. Ponieważ pliki tekstowe mogą mieć bardzo różną postać, funkcja ta ma wiele argumentów. Wybrane argumenty przedstawia poniższa deklaracja.
    
    read.table(file,
                header = FALSE,
                sep = "",
                dec = ".", 
                nrows = -1,
                skip = 0, comment.char = "#",
                stringsAsFactors = default.stringsAsFactors(), ...)


Ponieważ dane mogą być zapisane z użyciem różnych formatów, argumenty tej funkcji określają format danych do wczytania. Znaczenie kolejnych argumentów podane jest poniżej.

* `file` - ścieżka do pliku z danymi, może być też adres URL. Jeżeli wartości argumentów podajemy w ich domyślnej kolejności, to możemy pominąć nazwy argumentów (dlatego w kolejnych przykładach nie będziemy podawać nazwy tego argumentu).
* `header` - flaga określająca, czy pierwszy wiersz należy traktować jako nagłówek. W naszym przypadku header=TRUE.
* `sep` - znak rozdzielający kolumny. W naszym przypadku sep=";", ale popularnymi separatorami są również znak tabulacji (oznaczany \t), przecinek lub spacja. Separatorem może być dowolny, ale tylko jeden znak.
* `dec` - separator dziesiętny. Zazwyczaj jest to . lub ,. W naszym przypadku dec=",".
* `nrows` - maksymalna liczba wierszy do wczytania. Domyślnie ten argument przyjmuje wartość -1, czyli wczytaj wszystkie wiersze.
* `skip` - liczba pierwszych wierszy do pominięcia przy wczytywaniu danych, domyślnie 0, czyli nie pomijaj żadnego wiersza.
* `comment.char` - znak komentarza. Jeżeli w danych wystąpi ten znak to treść od tego znaku do końca linii będzie zignorowana.
* `stringsAsFactors` - czy napisy powinny być domyślnie przekształcone w zmienne jakościowe. Domyślnie TRUE.

Wynikiem funkcji read.table() jest tabelaryczny zbiór danych, który w R nazywa się ramką danych (ang. data.frame). 

***

**Pierwszy przykład** 

**UWAGA:** sprawdźć ścieżka dostępu do lokalizacji twojego pliku.

```{r}
dane <- read.table(file = "Z:/R/Kurs_R/dane/dane1_srednik.txt", # lokalizacja i nazwa pliku
                   header = TRUE, # czy zawiera nazwy kolumn
                   sep = ";", # separtor wartosci
                   dec=".") # separator miejsca dzisiętnego
```

```{r, eval=F}
dane 
View(dane)
```

**Drugi przykład**

Najpierw polecenie `setwd()` ustaw ścieżkę dostępu do katalogu.

```{r, eval=F}
setwd("z:/R/Kurs_R/dane/") # To nie jest twoja ścieżka
getwd()
```

Z powodzeniem wczytaliśmy dane, jeśli nie to sprawdźć ścieżke katalogu.

```{r}
dane2 <- read.table("dane2_przecinek.txt", # lokalizacja i nazwa pliku
                   header = TRUE, 
                   sep = ",", # przecinek  
                   dec=".")
```

```{r, eval=F}
dane2 
```

**Trzeci przykład:**

Otwórz plik "dane3_brudny.txt" w notatniku. Zauważ, że kilka wierzy danych jest nieprawidłowych.Dokłądnie są to wiersze od 1 i 2. Pomijamy je za pomocą argumentu `skip`.

```{r}
dane3 <- read.table("dane3_brudny.txt", # lokalizacja i nazwa pliku
                   header = TRUE, 
                   sep = ";",  
                   dec=".", skip = 2)
```

```{r, eval=F}
dane3 
```

**czwarty przykład:**

Funkcją `read.table()` można wczytać również pliki .csv. Otwórz plik "dane1_srednik.csv" w w notatniku.

```{r}
dane4 <- read.table("dane1_srednik.csv", # lokalizacja i nazwa pliku
                   header = TRUE, 
                   sep = ";",  
                   dec=".")
```

lub funkcja `read.csv`:

```{r}
read.csv("dane1_srednik.csv", sep = ";") -> dane6
```

Pliki można też pobierać za posrednictwem adresu internetowego.

```{r}
dane7 <- read.table(file = "http://biecek.pl/MOOC/dane/koty_ptaki.csv", 
                    sep=";", dec=",", header=TRUE)

read.csv(file = "http://biecek.pl/MOOC/dane/koty_ptaki.csv", sep = ";") -> dane7
```

***

### 4.2.2. Wczytywanie plików xlsx.

Aby wczytać pliki xlsx, lub xls trzeba zainstalować i załadować pakiet `openxlsx`

```{r, eval=FALSE}
install.packages("openxlsx")
```

```{r}
library(openxlsx)
```

W folerze dane znajduje się plik, który składa się z dwóch arkuszy danych. Najpierw wczytamy arkusz dane, a potem arkusz koty_ptaki.

```{r}
openxlsx::read.xlsx("dwa_arkusze.xlsx", sheet = 1) -> dane
dane
```

Teraz drugi arkusz:

```{r}
read.xlsx("dwa_arkusze.xlsx", sheet = 2) -> zwierz
zwierz
```

***

### 4.2.3. pliki binarne

Natywnym formatem dla programu R są pliki binarne o rozszerzeniu `.rda` lub `.RData`. Dane w tym formacie są skompresowane, przez co zajmują mniej miejsca na dysku niż w pliku tekstowym lub formacie Excela. Wadą jest to, że niewiele programów poza programem R potrafi je odczytać.

Dane w tym formacie można wczytać do programu R poleceniem `load()`. Pierwszym argumentem tej funkcji jest ścieżka do pliku z danymi. Jeżeli chcemy dane odczytać z internetu, należy dodatkowo użyć funkcji `url()`.

Uwaga !!! W przeciwieństwie do wcześniej poznanych funkcji, funkcja `load()` nie zwraca zbioru danych jako wynik, ale ładuje zbiór danych bezpośrednio do przestrzeni nazw (dane zapisane są wraz z nazwą zmiennej). 

```{r}
load(url("http://biecek.pl/MOOC/dane/koty_ptaki.rda"))
load("dane.RData")
```

***

## 4.3. Zapisywanie danych 

Zapisywanie danych przebiega w sposób analogiczny. Funkcję różnią się z reguły nazwą, zamiast `read` jest `write`. Przykłady:

```{r}
getwd() # tu zapisujemy
write.table(dane, file = "write1.txt",  # txt
            sep = ";", dec = ".", 
            row.names = F, col.names = T)

write.table(dane, file = "write2.csv",  # csv
            sep = ",", dec = ".", 
            row.names = F, col.names = T)

write.csv(dane, file = "write3.csv", row.names = F)

write.xlsx(zwierz, file = "zwierz.xlsx")

save(dane, dane2, zwierz, koty_ptaki,
     file = "dane_all.RData") # można od razu zapisać kilka 
```

Usuwanie zapisanych plików.

```{r}
file.remove(c("dane_all.RData", "write1.txt", "write2.csv", "write3.csv", "zwierz.xlsx"))
```

***

# 5. Przetwarzanie tekstu

Napisy są jednym z podstawowych, często stosowanych rodzajów zmiennych. Napisy możemy przekształcać (np. data, którą można przekształcić na napisy by wyłuskać rok i miesiąc). W tym rozdziale omówimy jak przekształcać napisy i wykonywać na nich operacje. W ramach tego rozdziału poznasz funkcje:

* `cat()`
* `paste()`
* `nchar()`
* `which()`
* `grep()`
* `grepl()`
* `gsub()`
* `substr()`
* `toupper()`
* `tolower()`

***

## 5.1 Wprowadzenie

**Typ znakowy**. Wartościami obiektów tego typu są napisy (inaczej łańcuchy znaków). W programie R napisy rozpoczynane są znakiem ' lub " oraz kończone takim samym znakiem np.: `"słowo"`. W łańcuchu znaków mogą występować dowolne znaki w tym znaki specjalne rozpoczynające się od znaku \. Wybrane znaki specjalne to: 
\n – znak nowej linii, 
\t – znak tabulacji, 
\\ – oznaczający znak \, 
\" – oznaczający ",   itp. 

Z łańcuchów znaków można wycinać fragmenty, sklejać, wyszukiwać podciągi znaków i wykonywać wiele innych operacji, o których napiszemy w kolejnych podrozdziałach.[źródło]

```{r}
"To jest napis" 
'To tez jest napis' 
"To jest napis 'a to jest napis wewnetrzny'" 
```

Funkcjami `tolower()` i `toupper` mozemy odpowiednio zmienic wielkość liter.

```{r}
tolower(LETTERS)
toupper(letters)
```

Natomiast przydatną funcją jest `toString`, która wstawia przecinki pomiedzy wyświetlane elementy wektora i przekształca wiele napisów w jeden element.

```{r}
letters[1:5] ; toString(letters[1:5])
```


Funkcja `cat()` wyświetla napis w sposób niesformatowany.

```{r}
cat(" co \t to \\ teraz\"\n\n bedzie?") 
```

Napisy można sklejać, za pomocą funkcji `paste()`.

```{r}
paste("Napis", "napis doklejony", 12) 
```

***

## 5.2. Konwersje napisów

Wybierzmy kolumnę `nazwisko`. W zbiorze danych `dane` jest to zmienna jakościowa (factor). Użyjemy funkcji as.character() by przekształcić ją na napisy. Otrzymane napisy zapiszemy w kolumnie `nazw_nap`.

```{r}
class(dane$nazwisko) # typ ?
``` 

Tworzymy nowa kolumnę w zestawie danych typu charakter.

```{r}
dane$nazw_nap <- as.character(dane$nazwisko)
dane$nazw_nap
```

Teraz sprawdź klase.

```{r}
class(dane$nazw_nap)
```

Funkcja `length()` dla każdego wektora sprawdza jego długość (liczbę napisów). Funkcja `nchar()` dla napisu sprawdza liczbę znaków w każdym napisie w wektorze (długość każdego napisu).

```{r}
length(dane$nazw_nap)
nchar(dane$nazw_nap)
```

Napisy pojawiają się też, gdy wczytywane są dane ilościowe lub jakościowe, ale z jakiegoś powodu w procesie wczytywania dane te zinterpretowane zostały jako napisy (np. przez źle określone formatowanie). W takim przypadku napisy przekształcamy często na pożądany typ, np. ilościowy, jakościowy, datę itp.

```{r}
as.numeric("2016") # konwersja na liczbę
as.factor(c("A", "B", "A", "A")) # konwersja na zmienną jakościową
as.Date("2016-01-01") # konwersja na datę
```

***

## 5.3. Wyszukiwanie napisów

Częstą operacją na napisach jest wyszukanie tych, które pasują do wzorca. Jeżeli chodzi nam o zgodność co do znaku, to wygodne będzie użycie funkcji `which()`. Jako wynik zwraca indeksy, dla których określony warunek jest prawdziwy.

Które wartości wektora nazw_nap to Azja?

```{r}
which(dane$nazw_nap == "Kowalska")
```

Które wartości wektora nazw_nap to Nowy lub Ptak?

```{r}
which(dane$nazw_nap %in% c("Nowy", "Ptak"))
```

Często jednak, zamiast wymieniać wszystkie wartości, które chcemy wyszukać, wygodniejsze jest opisanie tych wartości przez pewien wzorzec. Do takiego wyszukiwania służy funkcja `grep()`. Testuje ona, w którym z napisów występuje określony ciąg znaków, a jako wynik zwraca numery napisów z tym ciągiem.

Sprawdźmy, które wiersze w kolumnie nazw_nap posiadają w nazwie znak "a". Pierwszym argumentem funkcji `grep()` jest wzorzec, drugim wektor napisów. Możemy te argumenty podać w innej kolejności, ale wtedy zmuszeni jesteśmy do podawania ich nazwy.

```{r}
grep("a", dane$nazw_nap)
```

lub:

```{r}
grep(dane$nazw_nap, pattern = "a")
```

Teraz możemy wybrać z tabeli przez indeksowanie wiersze, zwrócone funkcją `grep()`:

```{r}
dane[grep(dane$nazw_nap, pattern="a"), ]
```

Jeżeli zamiast indeksów chcemy otrzymać wartości (napisy), które zostały dopasowane, wtedy powinniśmy ustawić argument value na wartość TRUE.

```{r}
grep("a", dane$nazw_nap, value = TRUE)
```

Zróbmy to teraz dla kolumny nazwisko.

```{r}
str(dane$nazwisko) # to jest factor
grep("a", as.character(dane$nazw_nap), value = TRUE) # z konwersją
```

Możemy jeszcze tak:

```{r}
dane$nazwisko <- as.character(dane$nazwisko) # konwersja
grep("a", dane$nazw_nap, value = TRUE) # z konwersją
```


Innym przydatnym argumentem funkcji `grep()` jest możliwość określenia, że wyszukiwanie ma być wykonane z pominięciem informacji o wielkości znaków. Służy do tego argument ignore.case=TRUE.

```{r}
grep("A", dane$nazwisko, ignore.case = TRUE)
```

Określając wzorzec możemy wykorzystać wyrażenia regularne. Pozwalają one opisać pewną prawidłowość, którą chcemy wyszukać w danych. Wyrażenia regularne są często stosowane, aby sprawdzić czy napis jest na przykład mailem, numerem telefonu lub kodem pocztowym.

Poniższe wyrażenie, sprawdza czy początek napisu to litera A lub E.

```{r}
grep("^[Pt]", dane$nazwisko, value = F)
grep("^[Pt]", dane$nazwisko, value = T)
```

***

## 5.4. Fragmenty napisów

Kolejną przydatną funkcją do operowania na napisach jest `substr()`. Pozwala ona z napisu wyciąć fragment o określonej pozycji, drugim i trzecim argumentem są indeksy początku i końca napisu, który chcemy wyciąć.

Przykładowo, w ten sposób możemy z dat wycinać informację o latach lub miesiącach.

```{r}
daty <- c("2018-01-05", "2018-03-25", "2012-12-23")
substr(daty, 1, 4) # pierwsze 4
```

```{r}
substr(daty, 6, 7) # miesiące
```

```{r}
substr(daty, 9, 10) # dni
```

Innym sposobem wyłuskiwania elementu napisu jest podanie wzorca który rozdziela istotne elementy napisu, np. słowa. W poniższym przykładzie dwa zdania są rozbijane na wyrazy (a dokładniej rozbijane na fragmenty rozdzielane spacją). Wynikiem jest dwuelementowa lista wektorów. Wybieramy pierwszy wektor i odczytujemy z niego drugie słowo.

```{r}
zdanie <- c( "W Szczebrzeszynie chrząszcz brzmi w trzcinie", "Ząb zupa zębowa dąb zupa dębowa")
(podzielony <- strsplit(zdanie, " ")) # tworzy liste
```

***

## 5.5 Tworzenie nowych cech

Zainstaluj i wczytaj pakiet `PogromcyDanych` (patrz lekcja 1).

```{r, echo=FALSE, include=F}
library(PogromcyDanych)
```

Teraz przegladnij zesta danych auta2012 załądowany wraz z pakietem pogromcy danych.

```{r, eval=FALSE}
str(auta2012)
```

Przekonwertujemy dwie zmienne

```{r}
auta2012$Kolor_napis <- as.character(auta2012$Kolor)
```

W analizie danych często stoimy przed potrzebą stworzenia nowych cech na bazie starych. Przykładowo, jeżeli spojrzymy na wektor kolorów samochodów, możemy uznać że interesującą cechą byłoby określenie, czy lakier jest koloru metalicznego czy nie.

```{r, eval=F}
sort(table(auta2012$Kolor_napis))
```

Można zrobić to na kilka sposobów. Najłatwiejszym jest użycie funkcji `grepl(`), o takich samych parametrach jak funkcja `grep()` z tym wyjątkiem, że wynikiem jest wektor wartości logicznych `TRUE` i `FALSE` określający czy dany wzorzec został odnaleziony czy nie w napisach.

```{r}
auta2012$czy_metallic <- grepl("metallic", auta2012$Kolor_napis)
table(auta2012$czy_metallic)
```

***

## 5.6. Sklejanie napisów

Funkcje `paste()` już poznaliście, teraz omówimy troszkę bardziej skomplikowany przykład.

Przedstawmy funkcję do sklejania napisów na przykładzie sklejania nazwy marki i modelu dla auta. W pierwszej linii skleimy oba wektory, używając za separator ': '. Następnie zliczymy ile było wystąpień takich par i uporządkujemy je w kolejności malejącej. Wyświetlamy 25 najczęstszych modeli.

```{r}
auta2012$MarkaModel   <- paste(auta2012$Marka, auta2012$Model, sep=": ")
statystykiMarkiModelu <- sort(table(auta2012$MarkaModel), decreasing = TRUE)
statystykiMarkiModelu[1:25] # to jest obiekt table
```

***

## 5.7. Liczby, cechy jakościowe i napisy

Funkcja `as.character()` może być przydatna jeszcze w jednej sytuacji, tzn. gdy zmienną jakościową chcemy przekształcić na zmienną liczbową. Nie powinniśmy tego zrobić bezpośrednio, ale poprzez funkcję `as.character()`. Pokażmy ten problem na przykładzie. Zamienimy zmienne na zmienne jakościowe funkcją `as.factor()` a następnie na liczby funkcją `as.numeric()`. Okazuje się jednak, że wynik nie jest zgodny z oczekiwaniami.

```{r}
x <- c(2, 4, 5.5)
fx <- as.factor(x) ; fx
```

**Uwaga!** Program R nie wie że to są napisy, a zmienną jakościową zamienia na kolejne liczby całkowite.

```{r}
as.numeric(fx)
```

Zmienne jakościowe przez funkcję as.numeric() zamieniane są na kolejne liczby całkowite. Jeżeli chcemy odzyskać liczby, które są treścią czynników, to musimy je wpierw zamienić na napisy, funkcją as.character().

```{r}
as.numeric(as.character(fx))
```

***

## 5.8. Co dalej

W ramach rozdziału 5 dowiedzieliście się trochę o możliwościach przetwarzania tekstu z wykorzystaniem istniejacych funkcji w R. Wiecej o operacjach na zmiennych tekstowych znajdziecie w @Wickham:2017:RDS:3086927 w rozdziale `14. Strings` [(link)](http://r4ds.had.co.nz/strings.html). Dodatkowo zalecam pobranie [cheat sheet](https://github.com/rstudio/cheatsheets/raw/master/strings.pdf) do pakietu `stringr`.

#####

***

##### Ćwiczenie 11 {.tabset .tabset-pills}
###### Treść 

1. Wyznacz indeksy wierszy w zbiorze danych `dane`, w których `stanow` literę `i`.
2. Wyznacz wszystkie wiersze, w których opisano osoby pracujące na AGH i NFZ.
3. Sprawdź ile samochodów ma zainstalowany autoalarm (oznaczony jako ‘autoalarm’).
4. Sprawdź ile samochodów ma lakier w metalicznym kolorze (oznaczony jako ‘metallic’).


###### Odp. 

Wyznacz indeksy wierszy w zbiorze danych `dane`, w których `stanow` literę `i`.

```{r}
grep("i", dane$stanow)
```

Wyznacz wszystkie wiersze, w których opisano osoby pracujące na AGH i NFZ.

```{r}
dane[dane$praca %in% c("AGH","NFZ"),]
```

Sprawdź ile samochodów ma zainstalowany autoalarm (oznaczony jako autoalarm).

```{r}
library(PogromcyDanych)
data(package = "PogromcyDanych")
auta2012 <-  auta2012
```
```{r}
auta2012$autoalarm <- grepl("autoalarm", auta2012$Wyposazenie.dodatkowe)
table(auta2012$autoalarm) -> a
a ; (a[2]/sum(a))*100 # procent z autoalarm
```


Sprawdź ile samochodów ma alufelgi i ABS.

```{r}
auta2012$ABS <- grepl("ABS", auta2012$Wyposazenie.dodatkowe)
table(auta2012$ABS)
auta2012$ALU <- grepl("alufelgi", auta2012$Wyposazenie.dodatkowe)
table(auta2012$ALU)

sum(auta2012$ABS == TRUE & auta2012$ALU == TRUE) -> a # TRUE = 1
a ; paste(round((a/nrow(auta2012))*100,1), "%")
```

#####

***

# 6. Przetwarzanie daty

Analizując dane spotkamy się z zmiennymi związanymi z datami i czasem. W tym rozdziale dowiedzą się Państwo jak tworzyć zmienne opisujące datę i czas, jakie operacje są wykonywane na tych zmiennych, jak je podsumowywać. W programie R istnieją trzy podstawowe typy zmiennych opisujące daty lub czas.

* Klasa `Date` służy do opisywania dat z dokładnością do dnia. Na datach można wykonywać operacje takie jak odejmowanie dwóch dat, dodawanie liczby do dnia itp.
* Klasa `POSIXct`, służy do opisywania czasu z dokładnością do sekundy. Czas jest pamiętany jako liczba sekund od określonego początku. Sufiks `ct` oznacza calendar time.
* Klasa `POSIXlt`, służy do opisywania czasu w formacie listy wartości. Sufiks `lt` oznacza local time.

***
## 6.1. Obiekty klasy date

Konstruktorem klasy Date jest funkcja `as.Date()`.

Jako pierwszy argument przyjmuje wektor napisów opisujących daty. Drugi opcjonalny argument określa formatowanie daty. Domyślne formatowanie to rok-miesiąc-dzień.

```{r}
as.Date("2015-02-22")
as.Date("02/22/2015", format = "%m/%d/%Y")
as.Date("Czerwiec 2, 2015", format = "%B %d, %Y")
```

Obiekty klasy Date można tworzyć także na podstawie liczb całkowitych lub obiektów klasy `POSIXct`, w obu przypadkach przy pomocy funkcji `as.Date()`.

```{r}
?strptime ## zasięgnijmy pomocy i zróbmy kilka przykładów 
```

Sformatujemy czas lokalny:  

```{r}
Sys.time()
format(Sys.time(), "%a %b %d %X %Y %Z")
format(Sys.time(), "%H:%M:%OS3")
```

Teraz sformatujemy wybraną datę:

```{r}
a <- as.Date("2014-03-21") ;a
format(a, "%a %b %d %X %Y %Z")
format(a, "%H:%M:%OS3")
```

Spróbujemy utworzyć zmienną `POSIXct()`:

```{r}
dates <- c("02/27/92", "02/27/92", "01/14/92", "02/28/92", "02/01/92")
times <- c("23:03:20", "22:29:56", "01:03:30", "18:21:03", "16:56:26")
x <- paste(dates, times) ## tworzymy listę
strptime(x, "%m/%d/%y %H:%M:%S") ## tworzymy POSIXlt
a <- strptime(x, "%m/%d/%y %H:%M:%S")
a
```

UWAGA !! śledzić uważnie wykonywane czynności i obserwuj metody tworzenia szeregów dat

***

## 6.2. Czas ct() calender time

Konstruktorem klasy POSIXct jest funkcja `as.POSIXct()`. Jako pierwszy argument przyjmuje wektor napisów opisujących chwile czasu. Drugi opcjonalny argument określa formatowanie daty. Domyślne formatowanie to rok-miesiąc-dzień godzina:minuta:sekunda.

```{r}
(czas1 <- as.POSIXct("2015-02-13 12:56:26"))
(czas2 <- as.POSIXct("14022015 12:56:26", 
                     format = "%d%m%Y %H:%M:%S"))
```

Na czasach można wykonywać takie operacje jak odejmowanie czy dodawane do określonego przedziału czasu (dodanie liczby całkowitej, domyślnie dodaje określoną liczbę sekund).

```{r}
# różnica czasów
czas2 - czas1
czas1 ; czas1 + 30 # + 30 sekund
czas1 ; czas1 + (24*60*60) # + 1 dzień
czas1 ; czas1 + 7*(24*3600) # + 7 dni
```

Funkcja `Sys.time()` jako wynik zwraca aktualny czas w formacie `POSIXct`.

```{r}
Sys.time()
Sys.time() - czas1 
Sys.timezone() ## zwraca strefę czasową
```

***

## 6.3  Czas lt() local time

Konstruktorem klasy `POSIXlt` jest funkcja `as.POSIXlt()`. Jako pierwszy argument przyjmuje wektor napisów opisujących chwile czasu. Drugi opcjonalny argument określa formatowanie daty. Opis formatowania stosuje się taki sam, jak w przypadku klasy `POSIXct`.

```{r}
(czas1 <- as.POSIXlt("2015-02-13 12:56:26"))
(czas2 <- as.POSIXlt("14022015 12:56:26", 
                     format = "%d%m%Y %H:%M:%S"))
```

Obiekty klasy `POSIXlt` to listy, można się do ich elementów odwoływać przez nazwę.

```{r}
czas1$sec
czas1$min
czas1$zone
```

Wiele funkcji można stosować zamiennie do obiektów klasy `POSIXlt` i `POSIXct`

```{r}
czas2 - czas1
czas1 + 7*3600 # 7 godzin
```

***

## 6.4. Pakiet lubridate

W podstawowym programie R operacje na datach i czasie nie zawsze są proste. Tzn. proste operacje są proste, ale złożone już niekoniecznie. Pakiet `lubridate` zawiera zestaw funkcji ułatwiający pracę z datami. Instalujemy i wczytujemy:

```{r, eval=F}
install.packages("lubridate")
```
```{r}
library(lubridate)
```

Jedną z takich funkcji jest `now()`, która zwraca obiekt opisujący bieżącą chwilę.

```{r}
now() # do sekundy
today() # do dnia
```

Uproszczono nazwy funkcji, służące do konwertowania napisów na czas. Nazwa funkcji staje się opisem formatu.

```{r}
ymd_hms("2015-02-14 23:59:59")
(czas3 <- mdy_hm("02/14/15 08:32"))
```

Z dat można wyłuskiwać takie informacje jak dzień tygodnia, dzień miesiąca itd. Funkcją `wday()` można odczytać dzień tygodnia, podobnie funkcje `day()`, `month()` i `year()` opisują składowe daty.

```{r}
wday(czas3, label = TRUE)
```

Tydzień w roku, dzień miesiąca, miesiąc i rok.

```{r}
week(czas1)
day(czas1)
month(czas1)
year(czas1)
```

Na czasach można wykonywać wygodne operacje używając funkcji `days(`), `months()`, `years()`, `minutes()`, `seconds()`.

```{r}
czas3 + hours(4)
czas3 + days(2) + months(4) + years(1)
```

*** 

## 6.7. Co dalej

W ramach rozdziału 6 dowiedzieliście się trochę o możliwościach przetwarzania daty z wykorzystaniem istniejacych funkcji w R. Wiecej o operacjach na zmiennych tekstowych znajdziecie w @Wickham:2017:RDS:3086927 w rozdziale `16. Dates and Times` [(link)](http://r4ds.had.co.nz/strings.html). Dodatkowo zalecam pobranie [cheat sheet](https://github.com/rstudio/cheatsheets/raw/master/lubridate.pdf) do pakietu `stringr`.

##### Ćwiczenie 12 {.tabset .tabset-pills}
###### Treść 

* Używając odpowiedniego formatowania zamień napis 01-15-2015 10:20:59 na obiekt klasy POSIXct.
* Oblicz liczbę dni pomiędzy 1 września 1945 roku a 8 maja 1945.
* Sprawdź jaki dzień tygodnia będzie za 100 dni od dziś

###### Odp. 

* Używając odpowiedniego formatowania zamień napis 01-15-2015 10:20:59 na obiekt klasy POSIXct.

```{r}
a <- "01-15-2015 10:20:59"
as.POSIXct(a, format = "%m-%d-%Y %H:%M:%S")
```

* Oblicz liczbę dni pomiędzy 1 września 1945 roku a 8 maja 1945.

```{r}
a <- as.Date("1945-09-01")
b <- as.Date("1945-05-08")
b-a
```

* Sprawdź jaki dzień tygodnia, miesiąc, rok, będzie za 100 dni od dziś

```{r}
a <- Sys.time() ; a 
b <- a + 100*24*3600 ; b
wday(b, label = T)
month(b, label = T)
year(b)
```

####

***





# 7. Typ czynnikowy - cechy jakościowe

**Typ czynnikowy (nazywany również wyliczeniowym lub kategorycznym)**. Ten typ jest przydatny do przechowywania wektorów wartości występujących na kilku poziomach (w kilku kategoriach). Przykładowo płeć występuje na dwóch poziomach, tzn. może przyjmować tylko dwie wartości, dlatego przechowując w programie R wektor danych opisujących płeć, najlepiej użyć typu czynnikowego. Zmienne tego typu są najczęściej wykorzystywane do definiowania grup. Na poniższym przykładzie konstruujemy czteroelementowy wektor elementów typu wyliczeniowego, ze słownikiem składającym się z dwóch wartości [@biecek2008przewodnik]. 

```{r}
nz <- factor(c("sierzant", "kapitan", 
               "sierzant", "sierzant"))
nz
```

Zmienna nz jest obiektem czynnikowym składającym się z 4 elemetów tekstowych utworzonych z dwóch słów. Każde słowo reprezentuje kategorię.

Przejrzyjmy sie danym typu `factor`:
```{r, eval=FALSE}
summary(nz)
table(nz)
str(dane)
```

***

## 7.1. Wprowadzenie

Za pomocą cech jakościowych opisujemy przynależność danego zbioru danych do pewnej grup. Często cechę tą nazywa się grupową, a w R cechę jakościową oznacza obiekt typu `factor()` czynniki (cecha czynnikowa). Przykładami zmiennych jakościowych są: np. Wykształcenie (podstawowe, średnie, wyższe, specjalistyczne), kraj zamieszkania(PL, GER, RUS ....). 

Czasami zmienną jakościowa opisujemy liczbami jest to np. nr albumu, nr telefonu, pesel, kod pocztowy. Zmienną jakosciową, może być np.: Ocena końcowa z TI, ale można ją też traktować jako zmienną ilościową. Tutaj mamy do czynienia z dualnością i jak będzie ta zmienna interpretowana zależny od celu naszych analiz.

Dane jakościowe, lub grupowanie danych jest bardzo ważne ponieważ stanowi podstawę do utworzenia baz danych, oraz pozyskania z baz danych odpowiednich informacji. 

Jakkolwiek zmienne jakościowe mogą bardzo różnić się liczbą grup oraz rodzajem grup, można na nich wykonywać kilka wspólnych operacji. omówimy jej w tym rozdziale. Najpierw jednak proszę wczytać zestawy danych `dane` oraz z pakietu `PogromcyDanych` zestaw `auta2012`.

## 7.2. Cechy jakosciowe

Wczytaj zestaw danych `dane` z pliku `"dane.RData"`.

```{r}
getwd() # gdzie jestem 
# setwd("tam gdzie plik dane.RData") # ustaw lokalizację 
load(file = "dane.RData")
```

W celu pewnego uproszczenie skleimy imie i nazwisko w jedną kolumnę (patrz przetwarzanie danych tekstowych)

```{r}
osoba <- paste(dane$imie, 
               dane$nazwisko) 
osoba # nowa cecha

dane <- cbind(osoba,  # dodawanie kolumny
              dane[,3:ncol(dane)]) # selekcja 
dane[,1:4] # kulmny imie i nazwisko zastąpiono kolumną osoba
```

Gdy te zmienne są wyświetlane, poza wartościami dodatkowo wyświetlany jest zbiór wszystkich możliwych wartości. Ten zbiór nazywa się najczęściej poziomami zmiennej jakościowej lub słownikiem zmiennej. Sprawdźmy tym zmiennej wybranych kolumn poleceniem `class()`.

```{r}
class(dane$osoba)
class(dane$praca)
class(dane$zarobki)
```

Jeżeli wynikiem jest napis `factor` to mamy do czynienia ze zmienną jakościową. Jeżeli wynikiem jest `integer` lub `numeric` to mamy do czynienia ze zmienną ilościową. Teraz znane wam polecenie `str()`.

```{r, eval=FALSE}
View(dane)
str(dane)
```

Bardzo podobną funkcją jest `glimpse()` z pakiety `dplyr` zawartego w megapakiecie `tidyverse`.

```{r}
library(tidyverse)
dplyr::glimpse(dane)
```

Otrzymaliśmy informacje, o klasie wszystkich kolumn(atrybótów) naszych danych. Przydatnymi funkcja mogą być również `laves()` i `table()`:

* `levels()` zwraca wektor napisów - poziomów zmiennej jakościowej.
* `table()` zwraca wektor liczebności każdego czynnika,

```{r, eval=F}
levels(dane$praca)
table(dane$kraj)
table(auta2012$Waluta)
```

Zmienne jakościowe często opisuje się tablicą liczebności, a więc informacją ile razy wystąpiła każda z wartości ze słownika. Tablicę liczebności można wyznaczyć funkcją `table()` lub `summary()`. Jeżeli w zmiennej jakościowej występują wartości brakujące, to funkcja `summary()` też napisze ile ich jest (funkcja `table()` domyślnie tego nie robi, można takie zachowanie wymusić dodając argument `useNA = "always"`).

```{r}
summary(auta2012$Waluta)
table(auta2012$Waluta, useNA = "always")
```

***

## 7.3. Procenty

W niniejszy rozdziale zastosujemy funkcje, które były już omawiane. Więc zrezygnowano z opisu. Proszę się zastanowić nad poniższymi poleceniami i określić co one wykonują.

```{r}
waluty <- table(auta2012$Waluta)
(frakcje <- prop.table(waluty))
(procenty <- 100*frakcje)
round(procenty, digits = 1)
zaokragloneProcenty <- round(procenty,1)
sort(zaokragloneProcenty)
sort(zaokragloneProcenty, decreasing = TRUE)
order(zaokragloneProcenty)
kolejnoscPosortowanych <- order(zaokragloneProcenty)
zaokragloneProcenty[kolejnoscPosortowanych]
zaokragloneProcenty[kolejnoscPosortowanych]
zaokragloneProcenty[rev(kolejnoscPosortowanych)]
```

***

## 7.4. Graficzne statystyki opisowe

Tabele liczebności są proste w interpretacji. Podobnie jednak jak w innych przypadkach, graficzne przedstawienie liczb pozwala na łatwiejsze dostrzeżenie co się dzieje w danych. Koniec końców, w tabeli liczb łatwo pomylić się nawet gdy chodzi o liczbę cyfr w liczbie. Na wykresie takie wartości natychmiast rzucają się w oczy. Więc zróbmy wykres słupkowy, modyfikując go po drodze:

```{r}

auta2012[as.numeric(as.character(auta2012$Rok.produkcji)) > 1995,] -> auta
rok <- table(auta$Rok.produkcji, useNA = "always" )
rok
```

Wykres słupkowy:

```{r}
barplot(rok) # ustawienia standardowe

barplot(as.table(rok),
        horiz = T, # poziomo
        las = 1) # # napisy poziomo

```

***

## 7.5. character or factor

`Character` to oczywiście nazwa typu zmiennej reprezentującej napisy, czyli po prostu tekst
`factor` to oczywiście nazwa typu zmiennej reprezentującej grupy.

Z wyglądu, cechy jakościowe (czynniki) przypominają cechy napisowe. Jednak pod spodem, ich reprezentacja jest zupełnie inna. Czynniki nie są pamiętane jako napisy, ale jako para - wektor liczb i słownik, określający, który napis odpowiada, której liczbie.

Na napisach zazwyczaj wykonuje się inne operacje niż na zmiennych jakościowych, może się więc tak zdarzyć, że celowo chcemy jakieś dane odczytać jako napisy. Ale gdy dane są wczytywane z pliku tekstowego w którym są napisy, domyślnie traktowane są jako czynniki.

W poniższym przykładzie takie zmienne jak gatunek i habitat są wczytywane jako zmienna klasy factor. Efektem ubocznym jest sposób wyświetlania wyników np. przez zmienną `cat()`. Dla zmiennej czynnikowej, ta funkcja na ekranie wypisze liczby a nie wartości napisowe.

```{r}
cat(dane$praca)
cat(as.character(dane$praca))
```

```{r}
czynnik <- as.factor(dane$kraj) ; str(czynnik)
napisy <- as.character(dane$kraj) ; str(napisy)
```

***

## 7.6. Tablice częstości

Tablice częstości nie są ramkami danych, mimo że wyglądają bardzo podobnie.

A co gdybyśmy chcieli przedstawić zależność pomiędzy dwoma zmiennymi jakościowymi? Można to zrobić używając funkcji `table()` (należy kolejne kolumny(atrybuty) podawać jako kolejne argumenty). Przykładowe wywołanie dla dwóch zmiennych Waluty i Kraju pochodzenia.

```{r, eval=FALSE}
table(auta2012$Kraj.pochodzenia, auta2012$Waluta)
```

Jednak wygodniej jest, takie tabele tworzyć używając funkcji `xtabs()`, która jest trochę wygodniejsza w pracy. Pierwszym argumentem tej funkcji jest formuła o składni `~ zmienna_1 + .. + zmienna_n`, t.j. rozpoczynająca się `~`` a następnie ze zmiennymi porozdzielanymi znakiem `+`. Drugim argumentem jest ramka danych, która powinna zawierać zmienne wymienione w formule.

Wynikiem jest tablica kontyngencji o tylu wymiarach, ile zmiennych występuje w formule.

Przykładowo, zestawiając ze sobą kraj pochodzenia oraz walutę w ogłoszeniu, otrzymujemy tablicę częstości o wymiarach 32 wiersze i 8 kolumn. Pierwszy wiersz tej tabeli odpowiada pustej wartości kraju pochodzenia, stąd brak nazwy w pierwszym wierszu.


```{r}
krajWaluta <- xtabs( ~ Kraj.pochodzenia + Waluta, auta2012)
```

```{r, eval=FALSE}
krajWaluta # wyświetlamy
```

Funkcja `prop.table()` liczy procenty (z drugim argumentem =1 liczy procenty w wierszach)

```{r}
round(prop.table(krajWaluta, 1), 3)
```

Tablice częstości nie są ramkami danych.

Gdy w grę wchodzą dwie zmienne, to rzeczywiście wyglądają one jak ramki danych - mają wiersze i kolumny. Muszą być jednak czymś innym, ponieważ w sytuacji, gdy tablica kontyngencji dotyczy trzech lub większej liczby zmiennych to wynikowa macierz kontyngencji ma więcej wymiarów niż dwa.

Funkcją `as.data.frame` można przekształcić wielowymiarowe tabele do ramki danych. Otrzyma się w tym przypadku tak zwaną reprezentację rzadką macierzy kontyngencji, w której pierwsze kolumny opisują wszystkie kombinacje czynników zmiennych a ostatnia kolumna opisuje liczebność występowania poszczególnej kombinacji czynników.

```{r, eval=F}
xt <- xtabs(~Kraj.pochodzenia+Waluta, auta2012)
xt <- as.data.frame(xt)
xt[xt$Freq > 0, ]
```

***

## 7.7. Przekształcanie zmiennych ilościowych w jakościowe

Opisując dane ilościowe, często można ułatwić ich zrozumienie, jeżeli zmienne ilościowe podzieli się na przedziały. Takie przedziały są już zmienną jakościową. Zmienną jakościową z ilościowej można stworzyć używając funkcji `cut()`, która za pierwszy argument przyjmuje zmienną ilościową, a jako drugi liczbę przedziałów do zbudowania lub punkty odcięcia dla tych przedziałów.

W przykładzie poniżej przekształcimy zmienną `urlop` ze zbioru dane na dwa przedziały: 0-10, 10-20. Tak stworzoną zmienną dodamy do zbioru dane pod kateg.

```{r}
dane$kateg <- cut(dane$urlop, 
                  breaks = c(0,10,max(dane$urlop)))
table(dane$kateg)
barplot(table(dane$kateg))
```

Teraz wyświetlmy dane, posortowaną względem nowej zmiennej:

```{r}
sort(table(dane$kateg))
```

Dwuwymiarową tabelę wykreslimy za pomocą funkcji `mosaicplot()`. Rysuje ona tak zwany wykres mozaikowy przedstawiający jednocześnie wiele zależności. 

```{r}
levels(auta2012$Skrzynia.biegow)
levels(auta2012$Rodzaj.paliwa)
tab <- xtabs(~Rodzaj.paliwa + Skrzynia.biegow, auta2012)
```

```{r}
mosaicplot(tab, las=2, col=c("green", "blue", "red"))
```

Teraz dla obiektu `round(prop.table(krajWaluta, 1), 3)`

```{r}
krajWaluta <- xtabs( ~Waluta + Kraj.pochodzenia, auta2012)
mosaicplot(round(prop.table(krajWaluta, 1), 3), 
           col = c(2:(length(levels(auta2012$Kraj.pochodzenia)) + 1)
                   ), las =2
           )
```

Zróbmy coś innego. Wczytamy dane mydata i wygenerujemy wykres częstości przedziałów prędkości wiatru.

```{r, eval=F}
install.packages("openair")
library(openair)
View(mydata)
```

```{r,echo=F, include=F}
library(openair)
```

```{r}
mydata$p.ws <- cut(mydata$ws, c(0, 2,4,6,8, 10, max(mydata$ws, na.rm = T)))
a <- round(prop.table(table(mydata$p.ws)),4)*100
barplot(a,  las = 2, col = c("red", "green","blue", "yellow", "grey", "tomato4"), 
        xlab = "przedziały prędkosci wiatru [m/s]", ylab =  "Udziały wiatrów [%]")
```

***

##  7.8. Kolejność i nazwy czynników

Domyślna kolejność czynników, to kolejność leksykograficzna. Tworząc wykresy, zazwyczaj wartości prezentowane są zgodnie z kolejnością opisaną przez atrybut levels.

```{r}
levels(auta2012$Rodzaj.paliwa)
```

Stworzymy wykres roku produkcji względem rodzaju spalanego paliwa

```{r}
boxplot(Rok.produkcji ~ Rodzaj.paliwa, auta2012, las=2)
```

Domyślną kolejność można zmienić. Jednym ze sposobów określania kolejności czynników jest argument levels w funkcji `factor()`. Czynniki będą mieć kolejność zgodną z tam wskazaną. Nazwy czynników można też dowolnie zmieniać. Najprościej można to zrobić używając funkcji `levels()` tak jak na poniższym przykładzie.Nazwy czynników można też dowolnie zmieniać. Najprościej można to zrobić używając funkcji `levels()` tak jak na poniższym przykładzie.

```{r}
levels(auta2012$Skrzynia.biegow)

auta2012$Skrzynia.biegow <- factor(auta2012$Skrzynia.biegow, 
                                   levels=c("manualna","automatyczna", ""))
levels(auta2012$Skrzynia.biegow)
```

Jeżeli chcemy ,,posortować’’ poziomy zgodnie z pewną cechą ilościową, to wygodne będzie użycie funkcji `reorder()`. Jako argumenty pobiera ona wektor ze zmienną czynnikową, wektor z dowolną zmienną i funkcję. Dla każdej grupy określonej przez zmienną czynnikową, dla wartości wskazanych przez drugi argument wyznaczana jest wartość funkcji - trzeciego argumentu. Następnie czynniki są porządkowane zgodnie z kolejnością wyników trzeciej funkcji.

W przykładzie poniżej, rodzaje paliwa są porządkowane zgodnie ze średnim rokiem produkcji aut o określonym rodzaju paliwa. Tak jak się można spodziewać, bardziej ,,nowoczesne’’ paliwa są w autach młodszych.

```{r}
auta2012$sort <- reorder(auta2012$Rodzaj.paliwa, # jakościowa
                         auta2012$Rok.produkcji, # ilościowa
                         mean)
boxplot(Rok.produkcji ~ sort, auta2012, las=2)
boxplot(Rok.produkcji ~ sort, auta2012, 
        las=2, outline = F) # bez odstających obs.
```

*** 
##### Ćwiczenie 12 {.tabset .tabset-pills}
###### Treść 

[1] Ile zmiennych jakosciowych jest w w zbiorze danych `mydata` z pakietu `openair`?

[2] Cecha Marka opisuje markę samochodu. Sprawdź, która marka jest najpopularniejsza.

[3] Cecha Rodzaj.paliwa opisuje rodzaj paliwa wykorzystywanego przez auto. Czy jest to benzyna, olej, gaz? [4] Sprawdź jaki procent samochodów jest napędzana na benzynę?

[5] W zbiorze danych auta2012 podziel zmienne Rok.produkcji na przedziały 1900-1990, 1991-1995, 1996-2000, 2001-2005, 2006-2010, 2011-2012, a zmienną Przebieg.w.km na przedziały 0-1000, 1001-10 000, 10 001-100 000, 100 001 - 1000 000, 1000 000 - 10 000 000.

[6] Wyznacz tabelę liczebności dla tych dwóch nowych zmiennych.Przedstaw tę tabelę graficznie.

###### Odp.

Ile zmiennych jakosciowych jest w w zbiorze danych `mydata` z pakietu `openair`?

```{r}
str(mydata)
```

Cecha Marka opisuje markę samochodu. Sprawdź, która marka jest najpopularniejsza?

```{r}
head(sort(table(auta2012$Marka), decreasing = T),1)
tail(sort(table(auta2012$Marka)),1)
```

Cecha Rodzaj.paliwa opisuje rodzaj paliwa wykorzystywanego przez auto. Czy jest to benzyna, olej, gaz? 

```{r}
levels(auta2012$Rodzaj.paliwa)
```

Sprawdź jaki procent samochodów jest napędzana na benzynę?

```{r}
prop.table(table(auta2012$Rodzaj.paliwa))*100 -> a
sort(a, decreasing = T)

barplot(sort(a, decreasing = T),
        col =c(2:7)) #  numery kolorów
```

W zbiorze danych auta2012 podziel zmienne Rok.produkcji na przedziały 1900-1990, 1991-1995, 1996-2000, 2001-2005, 2006-2010, 2011-2012, a zmienną Przebieg.w.km na przedziały 0-1000, 1001-10 000, 10 001-100 000, 100 001 - 1000 000, 1000 000 - 10 000 000.

```{r}
p1 <- c(1900,1995,2000,2005,2010,2012)
p2 <- c(0, 1000, 10000, 100000, 1000000, 10000000)

auta2012$Rok.prod.prz <- cut(auta2012$Rok.produkcji, breaks = p1)
auta2012$Prze.km.prz <- cut(auta2012$Przebieg.w.km, breaks = p2)
```

Wyznacz tabelę liczebności dla tych dwóch nowych zmiennych.Przedstaw tę tabelę graficznie.

```{r}
table(auta2012$Rok.prod.prz, 
      auta2012$Prze.km.prz) -> a ;a
barplot(a, col = c(1:20))
```

####

***



